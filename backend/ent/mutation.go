// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/sut63/team08/ent/bloodtype"
	"github.com/sut63/team08/ent/certificate"
	"github.com/sut63/team08/ent/coveredperson"
	"github.com/sut63/team08/ent/department"
	"github.com/sut63/team08/ent/diagnose"
	"github.com/sut63/team08/ent/disease"
	"github.com/sut63/team08/ent/doctor"
	"github.com/sut63/team08/ent/drug"
	"github.com/sut63/team08/ent/examinationroom"
	"github.com/sut63/team08/ent/fund"
	"github.com/sut63/team08/ent/gender"
	"github.com/sut63/team08/ent/medical"
	"github.com/sut63/team08/ent/nurse"
	"github.com/sut63/team08/ent/operative"
	"github.com/sut63/team08/ent/operativerecord"
	"github.com/sut63/team08/ent/patient"
	"github.com/sut63/team08/ent/prefix"
	"github.com/sut63/team08/ent/prescription"
	"github.com/sut63/team08/ent/rent"
	"github.com/sut63/team08/ent/room"
	"github.com/sut63/team08/ent/roomtype"
	"github.com/sut63/team08/ent/schemetype"
	"github.com/sut63/team08/ent/tool"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeBloodtype       = "Bloodtype"
	TypeCertificate     = "Certificate"
	TypeCoveredPerson   = "CoveredPerson"
	TypeDepartment      = "Department"
	TypeDiagnose        = "Diagnose"
	TypeDisease         = "Disease"
	TypeDoctor          = "Doctor"
	TypeDrug            = "Drug"
	TypeExaminationroom = "Examinationroom"
	TypeFund            = "Fund"
	TypeGender          = "Gender"
	TypeMedical         = "Medical"
	TypeNurse           = "Nurse"
	TypeOperative       = "Operative"
	TypeOperativerecord = "Operativerecord"
	TypePatient         = "Patient"
	TypePrefix          = "Prefix"
	TypePrescription    = "Prescription"
	TypeRent            = "Rent"
	TypeRoom            = "Room"
	TypeRoomtype        = "Roomtype"
	TypeSchemeType      = "SchemeType"
	TypeTool            = "Tool"
)

// BloodtypeMutation represents an operation that mutate the Bloodtypes
// nodes in the graph.
type BloodtypeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_BTname              *string
	clearedFields        map[string]struct{}
	frombloodtype        map[int]struct{}
	removedfrombloodtype map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Bloodtype, error)
}

var _ ent.Mutation = (*BloodtypeMutation)(nil)

// bloodtypeOption allows to manage the mutation configuration using functional options.
type bloodtypeOption func(*BloodtypeMutation)

// newBloodtypeMutation creates new mutation for $n.Name.
func newBloodtypeMutation(c config, op Op, opts ...bloodtypeOption) *BloodtypeMutation {
	m := &BloodtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeBloodtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withBloodtypeID sets the id field of the mutation.
func withBloodtypeID(id int) bloodtypeOption {
	return func(m *BloodtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Bloodtype
		)
		m.oldValue = func(ctx context.Context) (*Bloodtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Bloodtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withBloodtype sets the old Bloodtype of the mutation.
func withBloodtype(node *Bloodtype) bloodtypeOption {
	return func(m *BloodtypeMutation) {
		m.oldValue = func(context.Context) (*Bloodtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m BloodtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m BloodtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *BloodtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetBTname sets the BTname field.
func (m *BloodtypeMutation) SetBTname(s string) {
	m._BTname = &s
}

// BTname returns the BTname value in the mutation.
func (m *BloodtypeMutation) BTname() (r string, exists bool) {
	v := m._BTname
	if v == nil {
		return
	}
	return *v, true
}

// OldBTname returns the old BTname value of the Bloodtype.
// If the Bloodtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *BloodtypeMutation) OldBTname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBTname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBTname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBTname: %w", err)
	}
	return oldValue.BTname, nil
}

// ResetBTname reset all changes of the "BTname" field.
func (m *BloodtypeMutation) ResetBTname() {
	m._BTname = nil
}

// AddFrombloodtypeIDs adds the frombloodtype edge to Patient by ids.
func (m *BloodtypeMutation) AddFrombloodtypeIDs(ids ...int) {
	if m.frombloodtype == nil {
		m.frombloodtype = make(map[int]struct{})
	}
	for i := range ids {
		m.frombloodtype[ids[i]] = struct{}{}
	}
}

// RemoveFrombloodtypeIDs removes the frombloodtype edge to Patient by ids.
func (m *BloodtypeMutation) RemoveFrombloodtypeIDs(ids ...int) {
	if m.removedfrombloodtype == nil {
		m.removedfrombloodtype = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfrombloodtype[ids[i]] = struct{}{}
	}
}

// RemovedFrombloodtype returns the removed ids of frombloodtype.
func (m *BloodtypeMutation) RemovedFrombloodtypeIDs() (ids []int) {
	for id := range m.removedfrombloodtype {
		ids = append(ids, id)
	}
	return
}

// FrombloodtypeIDs returns the frombloodtype ids in the mutation.
func (m *BloodtypeMutation) FrombloodtypeIDs() (ids []int) {
	for id := range m.frombloodtype {
		ids = append(ids, id)
	}
	return
}

// ResetFrombloodtype reset all changes of the "frombloodtype" edge.
func (m *BloodtypeMutation) ResetFrombloodtype() {
	m.frombloodtype = nil
	m.removedfrombloodtype = nil
}

// Op returns the operation name.
func (m *BloodtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Bloodtype).
func (m *BloodtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *BloodtypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._BTname != nil {
		fields = append(fields, bloodtype.FieldBTname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *BloodtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case bloodtype.FieldBTname:
		return m.BTname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *BloodtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case bloodtype.FieldBTname:
		return m.OldBTname(ctx)
	}
	return nil, fmt.Errorf("unknown Bloodtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BloodtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case bloodtype.FieldBTname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBTname(v)
		return nil
	}
	return fmt.Errorf("unknown Bloodtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *BloodtypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *BloodtypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *BloodtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Bloodtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *BloodtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *BloodtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *BloodtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Bloodtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *BloodtypeMutation) ResetField(name string) error {
	switch name {
	case bloodtype.FieldBTname:
		m.ResetBTname()
		return nil
	}
	return fmt.Errorf("unknown Bloodtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *BloodtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.frombloodtype != nil {
		edges = append(edges, bloodtype.EdgeFrombloodtype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *BloodtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeFrombloodtype:
		ids := make([]ent.Value, 0, len(m.frombloodtype))
		for id := range m.frombloodtype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *BloodtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfrombloodtype != nil {
		edges = append(edges, bloodtype.EdgeFrombloodtype)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *BloodtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case bloodtype.EdgeFrombloodtype:
		ids := make([]ent.Value, 0, len(m.removedfrombloodtype))
		for id := range m.removedfrombloodtype {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *BloodtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *BloodtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *BloodtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Bloodtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *BloodtypeMutation) ResetEdge(name string) error {
	switch name {
	case bloodtype.EdgeFrombloodtype:
		m.ResetFrombloodtype()
		return nil
	}
	return fmt.Errorf("unknown Bloodtype edge %s", name)
}

// CertificateMutation represents an operation that mutate the Certificates
// nodes in the graph.
type CertificateMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	_Certificate_Name                 *string
	clearedFields                     map[string]struct{}
	_Certificate_CoveredPerson        map[int]struct{}
	removed_Certificate_CoveredPerson map[int]struct{}
	done                              bool
	oldValue                          func(context.Context) (*Certificate, error)
}

var _ ent.Mutation = (*CertificateMutation)(nil)

// certificateOption allows to manage the mutation configuration using functional options.
type certificateOption func(*CertificateMutation)

// newCertificateMutation creates new mutation for $n.Name.
func newCertificateMutation(c config, op Op, opts ...certificateOption) *CertificateMutation {
	m := &CertificateMutation{
		config:        c,
		op:            op,
		typ:           TypeCertificate,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCertificateID sets the id field of the mutation.
func withCertificateID(id int) certificateOption {
	return func(m *CertificateMutation) {
		var (
			err   error
			once  sync.Once
			value *Certificate
		)
		m.oldValue = func(ctx context.Context) (*Certificate, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Certificate.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCertificate sets the old Certificate of the mutation.
func withCertificate(node *Certificate) certificateOption {
	return func(m *CertificateMutation) {
		m.oldValue = func(context.Context) (*Certificate, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CertificateMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CertificateMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CertificateMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetCertificateName sets the Certificate_Name field.
func (m *CertificateMutation) SetCertificateName(s string) {
	m._Certificate_Name = &s
}

// CertificateName returns the Certificate_Name value in the mutation.
func (m *CertificateMutation) CertificateName() (r string, exists bool) {
	v := m._Certificate_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldCertificateName returns the old Certificate_Name value of the Certificate.
// If the Certificate object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *CertificateMutation) OldCertificateName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCertificateName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCertificateName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCertificateName: %w", err)
	}
	return oldValue.CertificateName, nil
}

// ResetCertificateName reset all changes of the "Certificate_Name" field.
func (m *CertificateMutation) ResetCertificateName() {
	m._Certificate_Name = nil
}

// AddCertificateCoveredPersonIDs adds the Certificate_CoveredPerson edge to CoveredPerson by ids.
func (m *CertificateMutation) AddCertificateCoveredPersonIDs(ids ...int) {
	if m._Certificate_CoveredPerson == nil {
		m._Certificate_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Certificate_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveCertificateCoveredPersonIDs removes the Certificate_CoveredPerson edge to CoveredPerson by ids.
func (m *CertificateMutation) RemoveCertificateCoveredPersonIDs(ids ...int) {
	if m.removed_Certificate_CoveredPerson == nil {
		m.removed_Certificate_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Certificate_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedCertificateCoveredPerson returns the removed ids of Certificate_CoveredPerson.
func (m *CertificateMutation) RemovedCertificateCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Certificate_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// CertificateCoveredPersonIDs returns the Certificate_CoveredPerson ids in the mutation.
func (m *CertificateMutation) CertificateCoveredPersonIDs() (ids []int) {
	for id := range m._Certificate_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetCertificateCoveredPerson reset all changes of the "Certificate_CoveredPerson" edge.
func (m *CertificateMutation) ResetCertificateCoveredPerson() {
	m._Certificate_CoveredPerson = nil
	m.removed_Certificate_CoveredPerson = nil
}

// Op returns the operation name.
func (m *CertificateMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Certificate).
func (m *CertificateMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CertificateMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Certificate_Name != nil {
		fields = append(fields, certificate.FieldCertificateName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CertificateMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case certificate.FieldCertificateName:
		return m.CertificateName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CertificateMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case certificate.FieldCertificateName:
		return m.OldCertificateName(ctx)
	}
	return nil, fmt.Errorf("unknown Certificate field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CertificateMutation) SetField(name string, value ent.Value) error {
	switch name {
	case certificate.FieldCertificateName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCertificateName(v)
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CertificateMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CertificateMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CertificateMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CertificateMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CertificateMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CertificateMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Certificate nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CertificateMutation) ResetField(name string) error {
	switch name {
	case certificate.FieldCertificateName:
		m.ResetCertificateName()
		return nil
	}
	return fmt.Errorf("unknown Certificate field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CertificateMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Certificate_CoveredPerson != nil {
		edges = append(edges, certificate.EdgeCertificateCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CertificateMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Certificate_CoveredPerson))
		for id := range m._Certificate_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CertificateMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Certificate_CoveredPerson != nil {
		edges = append(edges, certificate.EdgeCertificateCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CertificateMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Certificate_CoveredPerson))
		for id := range m.removed_Certificate_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CertificateMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CertificateMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CertificateMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Certificate unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CertificateMutation) ResetEdge(name string) error {
	switch name {
	case certificate.EdgeCertificateCoveredPerson:
		m.ResetCertificateCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown Certificate edge %s", name)
}

// CoveredPersonMutation represents an operation that mutate the CoveredPersons
// nodes in the graph.
type CoveredPersonMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	clearedFields       map[string]struct{}
	_Patient            *int
	cleared_Patient     bool
	_SchemeType         *int
	cleared_SchemeType  bool
	_Fund               *int
	cleared_Fund        bool
	_Certificate        *int
	cleared_Certificate bool
	done                bool
	oldValue            func(context.Context) (*CoveredPerson, error)
}

var _ ent.Mutation = (*CoveredPersonMutation)(nil)

// coveredpersonOption allows to manage the mutation configuration using functional options.
type coveredpersonOption func(*CoveredPersonMutation)

// newCoveredPersonMutation creates new mutation for $n.Name.
func newCoveredPersonMutation(c config, op Op, opts ...coveredpersonOption) *CoveredPersonMutation {
	m := &CoveredPersonMutation{
		config:        c,
		op:            op,
		typ:           TypeCoveredPerson,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCoveredPersonID sets the id field of the mutation.
func withCoveredPersonID(id int) coveredpersonOption {
	return func(m *CoveredPersonMutation) {
		var (
			err   error
			once  sync.Once
			value *CoveredPerson
		)
		m.oldValue = func(ctx context.Context) (*CoveredPerson, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().CoveredPerson.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCoveredPerson sets the old CoveredPerson of the mutation.
func withCoveredPerson(node *CoveredPerson) coveredpersonOption {
	return func(m *CoveredPersonMutation) {
		m.oldValue = func(context.Context) (*CoveredPerson, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CoveredPersonMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CoveredPersonMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *CoveredPersonMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientID sets the Patient edge to Patient by id.
func (m *CoveredPersonMutation) SetPatientID(id int) {
	m._Patient = &id
}

// ClearPatient clears the Patient edge to Patient.
func (m *CoveredPersonMutation) ClearPatient() {
	m.cleared_Patient = true
}

// PatientCleared returns if the edge Patient was cleared.
func (m *CoveredPersonMutation) PatientCleared() bool {
	return m.cleared_Patient
}

// PatientID returns the Patient id in the mutation.
func (m *CoveredPersonMutation) PatientID() (id int, exists bool) {
	if m._Patient != nil {
		return *m._Patient, true
	}
	return
}

// PatientIDs returns the Patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) PatientIDs() (ids []int) {
	if id := m._Patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "Patient" edge.
func (m *CoveredPersonMutation) ResetPatient() {
	m._Patient = nil
	m.cleared_Patient = false
}

// SetSchemeTypeID sets the SchemeType edge to SchemeType by id.
func (m *CoveredPersonMutation) SetSchemeTypeID(id int) {
	m._SchemeType = &id
}

// ClearSchemeType clears the SchemeType edge to SchemeType.
func (m *CoveredPersonMutation) ClearSchemeType() {
	m.cleared_SchemeType = true
}

// SchemeTypeCleared returns if the edge SchemeType was cleared.
func (m *CoveredPersonMutation) SchemeTypeCleared() bool {
	return m.cleared_SchemeType
}

// SchemeTypeID returns the SchemeType id in the mutation.
func (m *CoveredPersonMutation) SchemeTypeID() (id int, exists bool) {
	if m._SchemeType != nil {
		return *m._SchemeType, true
	}
	return
}

// SchemeTypeIDs returns the SchemeType ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SchemeTypeID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) SchemeTypeIDs() (ids []int) {
	if id := m._SchemeType; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSchemeType reset all changes of the "SchemeType" edge.
func (m *CoveredPersonMutation) ResetSchemeType() {
	m._SchemeType = nil
	m.cleared_SchemeType = false
}

// SetFundID sets the Fund edge to Fund by id.
func (m *CoveredPersonMutation) SetFundID(id int) {
	m._Fund = &id
}

// ClearFund clears the Fund edge to Fund.
func (m *CoveredPersonMutation) ClearFund() {
	m.cleared_Fund = true
}

// FundCleared returns if the edge Fund was cleared.
func (m *CoveredPersonMutation) FundCleared() bool {
	return m.cleared_Fund
}

// FundID returns the Fund id in the mutation.
func (m *CoveredPersonMutation) FundID() (id int, exists bool) {
	if m._Fund != nil {
		return *m._Fund, true
	}
	return
}

// FundIDs returns the Fund ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FundID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) FundIDs() (ids []int) {
	if id := m._Fund; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFund reset all changes of the "Fund" edge.
func (m *CoveredPersonMutation) ResetFund() {
	m._Fund = nil
	m.cleared_Fund = false
}

// SetCertificateID sets the Certificate edge to Certificate by id.
func (m *CoveredPersonMutation) SetCertificateID(id int) {
	m._Certificate = &id
}

// ClearCertificate clears the Certificate edge to Certificate.
func (m *CoveredPersonMutation) ClearCertificate() {
	m.cleared_Certificate = true
}

// CertificateCleared returns if the edge Certificate was cleared.
func (m *CoveredPersonMutation) CertificateCleared() bool {
	return m.cleared_Certificate
}

// CertificateID returns the Certificate id in the mutation.
func (m *CoveredPersonMutation) CertificateID() (id int, exists bool) {
	if m._Certificate != nil {
		return *m._Certificate, true
	}
	return
}

// CertificateIDs returns the Certificate ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// CertificateID instead. It exists only for internal usage by the builders.
func (m *CoveredPersonMutation) CertificateIDs() (ids []int) {
	if id := m._Certificate; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCertificate reset all changes of the "Certificate" edge.
func (m *CoveredPersonMutation) ResetCertificate() {
	m._Certificate = nil
	m.cleared_Certificate = false
}

// Op returns the operation name.
func (m *CoveredPersonMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (CoveredPerson).
func (m *CoveredPersonMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *CoveredPersonMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *CoveredPersonMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *CoveredPersonMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown CoveredPerson field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CoveredPersonMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown CoveredPerson field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *CoveredPersonMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *CoveredPersonMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *CoveredPersonMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown CoveredPerson numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *CoveredPersonMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *CoveredPersonMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *CoveredPersonMutation) ClearField(name string) error {
	return fmt.Errorf("unknown CoveredPerson nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *CoveredPersonMutation) ResetField(name string) error {
	return fmt.Errorf("unknown CoveredPerson field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *CoveredPersonMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Patient != nil {
		edges = append(edges, coveredperson.EdgePatient)
	}
	if m._SchemeType != nil {
		edges = append(edges, coveredperson.EdgeSchemeType)
	}
	if m._Fund != nil {
		edges = append(edges, coveredperson.EdgeFund)
	}
	if m._Certificate != nil {
		edges = append(edges, coveredperson.EdgeCertificate)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *CoveredPersonMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case coveredperson.EdgePatient:
		if id := m._Patient; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeSchemeType:
		if id := m._SchemeType; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeFund:
		if id := m._Fund; id != nil {
			return []ent.Value{*id}
		}
	case coveredperson.EdgeCertificate:
		if id := m._Certificate; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *CoveredPersonMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *CoveredPersonMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *CoveredPersonMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Patient {
		edges = append(edges, coveredperson.EdgePatient)
	}
	if m.cleared_SchemeType {
		edges = append(edges, coveredperson.EdgeSchemeType)
	}
	if m.cleared_Fund {
		edges = append(edges, coveredperson.EdgeFund)
	}
	if m.cleared_Certificate {
		edges = append(edges, coveredperson.EdgeCertificate)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *CoveredPersonMutation) EdgeCleared(name string) bool {
	switch name {
	case coveredperson.EdgePatient:
		return m.cleared_Patient
	case coveredperson.EdgeSchemeType:
		return m.cleared_SchemeType
	case coveredperson.EdgeFund:
		return m.cleared_Fund
	case coveredperson.EdgeCertificate:
		return m.cleared_Certificate
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *CoveredPersonMutation) ClearEdge(name string) error {
	switch name {
	case coveredperson.EdgePatient:
		m.ClearPatient()
		return nil
	case coveredperson.EdgeSchemeType:
		m.ClearSchemeType()
		return nil
	case coveredperson.EdgeFund:
		m.ClearFund()
		return nil
	case coveredperson.EdgeCertificate:
		m.ClearCertificate()
		return nil
	}
	return fmt.Errorf("unknown CoveredPerson unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *CoveredPersonMutation) ResetEdge(name string) error {
	switch name {
	case coveredperson.EdgePatient:
		m.ResetPatient()
		return nil
	case coveredperson.EdgeSchemeType:
		m.ResetSchemeType()
		return nil
	case coveredperson.EdgeFund:
		m.ResetFund()
		return nil
	case coveredperson.EdgeCertificate:
		m.ResetCertificate()
		return nil
	}
	return fmt.Errorf("unknown CoveredPerson edge %s", name)
}

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Department_Name           *string
	clearedFields              map[string]struct{}
	department_diagnose        map[int]struct{}
	removeddepartment_diagnose map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartmentName sets the Department_Name field.
func (m *DepartmentMutation) SetDepartmentName(s string) {
	m._Department_Name = &s
}

// DepartmentName returns the Department_Name value in the mutation.
func (m *DepartmentMutation) DepartmentName() (r string, exists bool) {
	v := m._Department_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartmentName returns the old Department_Name value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDepartmentName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartmentName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartmentName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartmentName: %w", err)
	}
	return oldValue.DepartmentName, nil
}

// ResetDepartmentName reset all changes of the "Department_Name" field.
func (m *DepartmentMutation) ResetDepartmentName() {
	m._Department_Name = nil
}

// AddDepartmentDiagnoseIDs adds the department_diagnose edge to Diagnose by ids.
func (m *DepartmentMutation) AddDepartmentDiagnoseIDs(ids ...int) {
	if m.department_diagnose == nil {
		m.department_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.department_diagnose[ids[i]] = struct{}{}
	}
}

// RemoveDepartmentDiagnoseIDs removes the department_diagnose edge to Diagnose by ids.
func (m *DepartmentMutation) RemoveDepartmentDiagnoseIDs(ids ...int) {
	if m.removeddepartment_diagnose == nil {
		m.removeddepartment_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddepartment_diagnose[ids[i]] = struct{}{}
	}
}

// RemovedDepartmentDiagnose returns the removed ids of department_diagnose.
func (m *DepartmentMutation) RemovedDepartmentDiagnoseIDs() (ids []int) {
	for id := range m.removeddepartment_diagnose {
		ids = append(ids, id)
	}
	return
}

// DepartmentDiagnoseIDs returns the department_diagnose ids in the mutation.
func (m *DepartmentMutation) DepartmentDiagnoseIDs() (ids []int) {
	for id := range m.department_diagnose {
		ids = append(ids, id)
	}
	return
}

// ResetDepartmentDiagnose reset all changes of the "department_diagnose" edge.
func (m *DepartmentMutation) ResetDepartmentDiagnose() {
	m.department_diagnose = nil
	m.removeddepartment_diagnose = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Department_Name != nil {
		fields = append(fields, department.FieldDepartmentName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartmentName:
		return m.DepartmentName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartmentName:
		return m.OldDepartmentName(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartmentName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartmentName(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartmentName:
		m.ResetDepartmentName()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.department_diagnose != nil {
		edges = append(edges, department.EdgeDepartmentDiagnose)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentDiagnose:
		ids := make([]ent.Value, 0, len(m.department_diagnose))
		for id := range m.department_diagnose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddepartment_diagnose != nil {
		edges = append(edges, department.EdgeDepartmentDiagnose)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeDepartmentDiagnose:
		ids := make([]ent.Value, 0, len(m.removeddepartment_diagnose))
		for id := range m.removeddepartment_diagnose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeDepartmentDiagnose:
		m.ResetDepartmentDiagnose()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// DiagnoseMutation represents an operation that mutate the Diagnoses
// nodes in the graph.
type DiagnoseMutation struct {
	config
	op                Op
	typ               string
	id                *int
	clearedFields     map[string]struct{}
	disease           *int
	cleareddisease    bool
	department        *int
	cleareddepartment bool
	patient           *int
	clearedpatient    bool
	doctor            *int
	cleareddoctor     bool
	done              bool
	oldValue          func(context.Context) (*Diagnose, error)
}

var _ ent.Mutation = (*DiagnoseMutation)(nil)

// diagnoseOption allows to manage the mutation configuration using functional options.
type diagnoseOption func(*DiagnoseMutation)

// newDiagnoseMutation creates new mutation for $n.Name.
func newDiagnoseMutation(c config, op Op, opts ...diagnoseOption) *DiagnoseMutation {
	m := &DiagnoseMutation{
		config:        c,
		op:            op,
		typ:           TypeDiagnose,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiagnoseID sets the id field of the mutation.
func withDiagnoseID(id int) diagnoseOption {
	return func(m *DiagnoseMutation) {
		var (
			err   error
			once  sync.Once
			value *Diagnose
		)
		m.oldValue = func(ctx context.Context) (*Diagnose, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Diagnose.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDiagnose sets the old Diagnose of the mutation.
func withDiagnose(node *Diagnose) diagnoseOption {
	return func(m *DiagnoseMutation) {
		m.oldValue = func(context.Context) (*Diagnose, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiagnoseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiagnoseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiagnoseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDiseaseID sets the disease edge to Disease by id.
func (m *DiagnoseMutation) SetDiseaseID(id int) {
	m.disease = &id
}

// ClearDisease clears the disease edge to Disease.
func (m *DiagnoseMutation) ClearDisease() {
	m.cleareddisease = true
}

// DiseaseCleared returns if the edge disease was cleared.
func (m *DiagnoseMutation) DiseaseCleared() bool {
	return m.cleareddisease
}

// DiseaseID returns the disease id in the mutation.
func (m *DiagnoseMutation) DiseaseID() (id int, exists bool) {
	if m.disease != nil {
		return *m.disease, true
	}
	return
}

// DiseaseIDs returns the disease ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DiseaseID instead. It exists only for internal usage by the builders.
func (m *DiagnoseMutation) DiseaseIDs() (ids []int) {
	if id := m.disease; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDisease reset all changes of the "disease" edge.
func (m *DiagnoseMutation) ResetDisease() {
	m.disease = nil
	m.cleareddisease = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *DiagnoseMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *DiagnoseMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *DiagnoseMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *DiagnoseMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *DiagnoseMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *DiagnoseMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetPatientID sets the patient edge to Patient by id.
func (m *DiagnoseMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to Patient.
func (m *DiagnoseMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *DiagnoseMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *DiagnoseMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *DiagnoseMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *DiagnoseMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *DiagnoseMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *DiagnoseMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *DiagnoseMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *DiagnoseMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *DiagnoseMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *DiagnoseMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// Op returns the operation name.
func (m *DiagnoseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Diagnose).
func (m *DiagnoseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiagnoseMutation) Fields() []string {
	fields := make([]string, 0, 0)
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiagnoseMutation) Field(name string) (ent.Value, bool) {
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiagnoseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	return nil, fmt.Errorf("unknown Diagnose field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiagnoseMutation) SetField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Diagnose field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiagnoseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiagnoseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiagnoseMutation) AddField(name string, value ent.Value) error {
	return fmt.Errorf("unknown Diagnose numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiagnoseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiagnoseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiagnoseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Diagnose nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiagnoseMutation) ResetField(name string) error {
	return fmt.Errorf("unknown Diagnose field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiagnoseMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.disease != nil {
		edges = append(edges, diagnose.EdgeDisease)
	}
	if m.department != nil {
		edges = append(edges, diagnose.EdgeDepartment)
	}
	if m.patient != nil {
		edges = append(edges, diagnose.EdgePatient)
	}
	if m.doctor != nil {
		edges = append(edges, diagnose.EdgeDoctor)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiagnoseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case diagnose.EdgeDisease:
		if id := m.disease; id != nil {
			return []ent.Value{*id}
		}
	case diagnose.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case diagnose.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case diagnose.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiagnoseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiagnoseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiagnoseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddisease {
		edges = append(edges, diagnose.EdgeDisease)
	}
	if m.cleareddepartment {
		edges = append(edges, diagnose.EdgeDepartment)
	}
	if m.clearedpatient {
		edges = append(edges, diagnose.EdgePatient)
	}
	if m.cleareddoctor {
		edges = append(edges, diagnose.EdgeDoctor)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiagnoseMutation) EdgeCleared(name string) bool {
	switch name {
	case diagnose.EdgeDisease:
		return m.cleareddisease
	case diagnose.EdgeDepartment:
		return m.cleareddepartment
	case diagnose.EdgePatient:
		return m.clearedpatient
	case diagnose.EdgeDoctor:
		return m.cleareddoctor
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiagnoseMutation) ClearEdge(name string) error {
	switch name {
	case diagnose.EdgeDisease:
		m.ClearDisease()
		return nil
	case diagnose.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case diagnose.EdgePatient:
		m.ClearPatient()
		return nil
	case diagnose.EdgeDoctor:
		m.ClearDoctor()
		return nil
	}
	return fmt.Errorf("unknown Diagnose unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiagnoseMutation) ResetEdge(name string) error {
	switch name {
	case diagnose.EdgeDisease:
		m.ResetDisease()
		return nil
	case diagnose.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case diagnose.EdgePatient:
		m.ResetPatient()
		return nil
	case diagnose.EdgeDoctor:
		m.ResetDoctor()
		return nil
	}
	return fmt.Errorf("unknown Diagnose edge %s", name)
}

// DiseaseMutation represents an operation that mutate the Diseases
// nodes in the graph.
type DiseaseMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_Disease_Name           *string
	clearedFields           map[string]struct{}
	disease_diagnose        map[int]struct{}
	removeddisease_diagnose map[int]struct{}
	done                    bool
	oldValue                func(context.Context) (*Disease, error)
}

var _ ent.Mutation = (*DiseaseMutation)(nil)

// diseaseOption allows to manage the mutation configuration using functional options.
type diseaseOption func(*DiseaseMutation)

// newDiseaseMutation creates new mutation for $n.Name.
func newDiseaseMutation(c config, op Op, opts ...diseaseOption) *DiseaseMutation {
	m := &DiseaseMutation{
		config:        c,
		op:            op,
		typ:           TypeDisease,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDiseaseID sets the id field of the mutation.
func withDiseaseID(id int) diseaseOption {
	return func(m *DiseaseMutation) {
		var (
			err   error
			once  sync.Once
			value *Disease
		)
		m.oldValue = func(ctx context.Context) (*Disease, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Disease.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDisease sets the old Disease of the mutation.
func withDisease(node *Disease) diseaseOption {
	return func(m *DiseaseMutation) {
		m.oldValue = func(context.Context) (*Disease, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DiseaseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DiseaseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DiseaseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDiseaseName sets the Disease_Name field.
func (m *DiseaseMutation) SetDiseaseName(s string) {
	m._Disease_Name = &s
}

// DiseaseName returns the Disease_Name value in the mutation.
func (m *DiseaseMutation) DiseaseName() (r string, exists bool) {
	v := m._Disease_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldDiseaseName returns the old Disease_Name value of the Disease.
// If the Disease object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DiseaseMutation) OldDiseaseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDiseaseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDiseaseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDiseaseName: %w", err)
	}
	return oldValue.DiseaseName, nil
}

// ResetDiseaseName reset all changes of the "Disease_Name" field.
func (m *DiseaseMutation) ResetDiseaseName() {
	m._Disease_Name = nil
}

// AddDiseaseDiagnoseIDs adds the disease_diagnose edge to Diagnose by ids.
func (m *DiseaseMutation) AddDiseaseDiagnoseIDs(ids ...int) {
	if m.disease_diagnose == nil {
		m.disease_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.disease_diagnose[ids[i]] = struct{}{}
	}
}

// RemoveDiseaseDiagnoseIDs removes the disease_diagnose edge to Diagnose by ids.
func (m *DiseaseMutation) RemoveDiseaseDiagnoseIDs(ids ...int) {
	if m.removeddisease_diagnose == nil {
		m.removeddisease_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddisease_diagnose[ids[i]] = struct{}{}
	}
}

// RemovedDiseaseDiagnose returns the removed ids of disease_diagnose.
func (m *DiseaseMutation) RemovedDiseaseDiagnoseIDs() (ids []int) {
	for id := range m.removeddisease_diagnose {
		ids = append(ids, id)
	}
	return
}

// DiseaseDiagnoseIDs returns the disease_diagnose ids in the mutation.
func (m *DiseaseMutation) DiseaseDiagnoseIDs() (ids []int) {
	for id := range m.disease_diagnose {
		ids = append(ids, id)
	}
	return
}

// ResetDiseaseDiagnose reset all changes of the "disease_diagnose" edge.
func (m *DiseaseMutation) ResetDiseaseDiagnose() {
	m.disease_diagnose = nil
	m.removeddisease_diagnose = nil
}

// Op returns the operation name.
func (m *DiseaseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Disease).
func (m *DiseaseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DiseaseMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Disease_Name != nil {
		fields = append(fields, disease.FieldDiseaseName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DiseaseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case disease.FieldDiseaseName:
		return m.DiseaseName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DiseaseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case disease.FieldDiseaseName:
		return m.OldDiseaseName(ctx)
	}
	return nil, fmt.Errorf("unknown Disease field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case disease.FieldDiseaseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDiseaseName(v)
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DiseaseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DiseaseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DiseaseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DiseaseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DiseaseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DiseaseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Disease nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DiseaseMutation) ResetField(name string) error {
	switch name {
	case disease.FieldDiseaseName:
		m.ResetDiseaseName()
		return nil
	}
	return fmt.Errorf("unknown Disease field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DiseaseMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.disease_diagnose != nil {
		edges = append(edges, disease.EdgeDiseaseDiagnose)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DiseaseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDiseaseDiagnose:
		ids := make([]ent.Value, 0, len(m.disease_diagnose))
		for id := range m.disease_diagnose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DiseaseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddisease_diagnose != nil {
		edges = append(edges, disease.EdgeDiseaseDiagnose)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DiseaseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case disease.EdgeDiseaseDiagnose:
		ids := make([]ent.Value, 0, len(m.removeddisease_diagnose))
		for id := range m.removeddisease_diagnose {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DiseaseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DiseaseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DiseaseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Disease unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DiseaseMutation) ResetEdge(name string) error {
	switch name {
	case disease.EdgeDiseaseDiagnose:
		m.ResetDiseaseDiagnose()
		return nil
	}
	return fmt.Errorf("unknown Disease edge %s", name)
}

// DoctorMutation represents an operation that mutate the Doctors
// nodes in the graph.
type DoctorMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Doctor_Name               *string
	_Doctor_Password           *string
	_Doctor_Email              *string
	_Doctor_tel                *string
	clearedFields              map[string]struct{}
	doctor_diagnose            map[int]struct{}
	removeddoctor_diagnose     map[int]struct{}
	doctor_prescription        map[int]struct{}
	removeddoctor_prescription map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Doctor, error)
}

var _ ent.Mutation = (*DoctorMutation)(nil)

// doctorOption allows to manage the mutation configuration using functional options.
type doctorOption func(*DoctorMutation)

// newDoctorMutation creates new mutation for $n.Name.
func newDoctorMutation(c config, op Op, opts ...doctorOption) *DoctorMutation {
	m := &DoctorMutation{
		config:        c,
		op:            op,
		typ:           TypeDoctor,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDoctorID sets the id field of the mutation.
func withDoctorID(id int) doctorOption {
	return func(m *DoctorMutation) {
		var (
			err   error
			once  sync.Once
			value *Doctor
		)
		m.oldValue = func(ctx context.Context) (*Doctor, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Doctor.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDoctor sets the old Doctor of the mutation.
func withDoctor(node *Doctor) doctorOption {
	return func(m *DoctorMutation) {
		m.oldValue = func(context.Context) (*Doctor, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DoctorMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DoctorMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DoctorMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDoctorName sets the Doctor_Name field.
func (m *DoctorMutation) SetDoctorName(s string) {
	m._Doctor_Name = &s
}

// DoctorName returns the Doctor_Name value in the mutation.
func (m *DoctorMutation) DoctorName() (r string, exists bool) {
	v := m._Doctor_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorName returns the old Doctor_Name value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldDoctorName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorName: %w", err)
	}
	return oldValue.DoctorName, nil
}

// ResetDoctorName reset all changes of the "Doctor_Name" field.
func (m *DoctorMutation) ResetDoctorName() {
	m._Doctor_Name = nil
}

// SetDoctorPassword sets the Doctor_Password field.
func (m *DoctorMutation) SetDoctorPassword(s string) {
	m._Doctor_Password = &s
}

// DoctorPassword returns the Doctor_Password value in the mutation.
func (m *DoctorMutation) DoctorPassword() (r string, exists bool) {
	v := m._Doctor_Password
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorPassword returns the old Doctor_Password value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldDoctorPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorPassword: %w", err)
	}
	return oldValue.DoctorPassword, nil
}

// ResetDoctorPassword reset all changes of the "Doctor_Password" field.
func (m *DoctorMutation) ResetDoctorPassword() {
	m._Doctor_Password = nil
}

// SetDoctorEmail sets the Doctor_Email field.
func (m *DoctorMutation) SetDoctorEmail(s string) {
	m._Doctor_Email = &s
}

// DoctorEmail returns the Doctor_Email value in the mutation.
func (m *DoctorMutation) DoctorEmail() (r string, exists bool) {
	v := m._Doctor_Email
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorEmail returns the old Doctor_Email value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldDoctorEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorEmail: %w", err)
	}
	return oldValue.DoctorEmail, nil
}

// ResetDoctorEmail reset all changes of the "Doctor_Email" field.
func (m *DoctorMutation) ResetDoctorEmail() {
	m._Doctor_Email = nil
}

// SetDoctorTel sets the Doctor_tel field.
func (m *DoctorMutation) SetDoctorTel(s string) {
	m._Doctor_tel = &s
}

// DoctorTel returns the Doctor_tel value in the mutation.
func (m *DoctorMutation) DoctorTel() (r string, exists bool) {
	v := m._Doctor_tel
	if v == nil {
		return
	}
	return *v, true
}

// OldDoctorTel returns the old Doctor_tel value of the Doctor.
// If the Doctor object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DoctorMutation) OldDoctorTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDoctorTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDoctorTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDoctorTel: %w", err)
	}
	return oldValue.DoctorTel, nil
}

// ResetDoctorTel reset all changes of the "Doctor_tel" field.
func (m *DoctorMutation) ResetDoctorTel() {
	m._Doctor_tel = nil
}

// AddDoctorDiagnoseIDs adds the doctor_diagnose edge to Diagnose by ids.
func (m *DoctorMutation) AddDoctorDiagnoseIDs(ids ...int) {
	if m.doctor_diagnose == nil {
		m.doctor_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.doctor_diagnose[ids[i]] = struct{}{}
	}
}

// RemoveDoctorDiagnoseIDs removes the doctor_diagnose edge to Diagnose by ids.
func (m *DoctorMutation) RemoveDoctorDiagnoseIDs(ids ...int) {
	if m.removeddoctor_diagnose == nil {
		m.removeddoctor_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctor_diagnose[ids[i]] = struct{}{}
	}
}

// RemovedDoctorDiagnose returns the removed ids of doctor_diagnose.
func (m *DoctorMutation) RemovedDoctorDiagnoseIDs() (ids []int) {
	for id := range m.removeddoctor_diagnose {
		ids = append(ids, id)
	}
	return
}

// DoctorDiagnoseIDs returns the doctor_diagnose ids in the mutation.
func (m *DoctorMutation) DoctorDiagnoseIDs() (ids []int) {
	for id := range m.doctor_diagnose {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorDiagnose reset all changes of the "doctor_diagnose" edge.
func (m *DoctorMutation) ResetDoctorDiagnose() {
	m.doctor_diagnose = nil
	m.removeddoctor_diagnose = nil
}

// AddDoctorPrescriptionIDs adds the doctor_prescription edge to Prescription by ids.
func (m *DoctorMutation) AddDoctorPrescriptionIDs(ids ...int) {
	if m.doctor_prescription == nil {
		m.doctor_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.doctor_prescription[ids[i]] = struct{}{}
	}
}

// RemoveDoctorPrescriptionIDs removes the doctor_prescription edge to Prescription by ids.
func (m *DoctorMutation) RemoveDoctorPrescriptionIDs(ids ...int) {
	if m.removeddoctor_prescription == nil {
		m.removeddoctor_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddoctor_prescription[ids[i]] = struct{}{}
	}
}

// RemovedDoctorPrescription returns the removed ids of doctor_prescription.
func (m *DoctorMutation) RemovedDoctorPrescriptionIDs() (ids []int) {
	for id := range m.removeddoctor_prescription {
		ids = append(ids, id)
	}
	return
}

// DoctorPrescriptionIDs returns the doctor_prescription ids in the mutation.
func (m *DoctorMutation) DoctorPrescriptionIDs() (ids []int) {
	for id := range m.doctor_prescription {
		ids = append(ids, id)
	}
	return
}

// ResetDoctorPrescription reset all changes of the "doctor_prescription" edge.
func (m *DoctorMutation) ResetDoctorPrescription() {
	m.doctor_prescription = nil
	m.removeddoctor_prescription = nil
}

// Op returns the operation name.
func (m *DoctorMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Doctor).
func (m *DoctorMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DoctorMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Doctor_Name != nil {
		fields = append(fields, doctor.FieldDoctorName)
	}
	if m._Doctor_Password != nil {
		fields = append(fields, doctor.FieldDoctorPassword)
	}
	if m._Doctor_Email != nil {
		fields = append(fields, doctor.FieldDoctorEmail)
	}
	if m._Doctor_tel != nil {
		fields = append(fields, doctor.FieldDoctorTel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DoctorMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case doctor.FieldDoctorName:
		return m.DoctorName()
	case doctor.FieldDoctorPassword:
		return m.DoctorPassword()
	case doctor.FieldDoctorEmail:
		return m.DoctorEmail()
	case doctor.FieldDoctorTel:
		return m.DoctorTel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DoctorMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case doctor.FieldDoctorName:
		return m.OldDoctorName(ctx)
	case doctor.FieldDoctorPassword:
		return m.OldDoctorPassword(ctx)
	case doctor.FieldDoctorEmail:
		return m.OldDoctorEmail(ctx)
	case doctor.FieldDoctorTel:
		return m.OldDoctorTel(ctx)
	}
	return nil, fmt.Errorf("unknown Doctor field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) SetField(name string, value ent.Value) error {
	switch name {
	case doctor.FieldDoctorName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorName(v)
		return nil
	case doctor.FieldDoctorPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorPassword(v)
		return nil
	case doctor.FieldDoctorEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorEmail(v)
		return nil
	case doctor.FieldDoctorTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDoctorTel(v)
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DoctorMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DoctorMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DoctorMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DoctorMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DoctorMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DoctorMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Doctor nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DoctorMutation) ResetField(name string) error {
	switch name {
	case doctor.FieldDoctorName:
		m.ResetDoctorName()
		return nil
	case doctor.FieldDoctorPassword:
		m.ResetDoctorPassword()
		return nil
	case doctor.FieldDoctorEmail:
		m.ResetDoctorEmail()
		return nil
	case doctor.FieldDoctorTel:
		m.ResetDoctorTel()
		return nil
	}
	return fmt.Errorf("unknown Doctor field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DoctorMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.doctor_diagnose != nil {
		edges = append(edges, doctor.EdgeDoctorDiagnose)
	}
	if m.doctor_prescription != nil {
		edges = append(edges, doctor.EdgeDoctorPrescription)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DoctorMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorDiagnose:
		ids := make([]ent.Value, 0, len(m.doctor_diagnose))
		for id := range m.doctor_diagnose {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorPrescription:
		ids := make([]ent.Value, 0, len(m.doctor_prescription))
		for id := range m.doctor_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DoctorMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removeddoctor_diagnose != nil {
		edges = append(edges, doctor.EdgeDoctorDiagnose)
	}
	if m.removeddoctor_prescription != nil {
		edges = append(edges, doctor.EdgeDoctorPrescription)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DoctorMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case doctor.EdgeDoctorDiagnose:
		ids := make([]ent.Value, 0, len(m.removeddoctor_diagnose))
		for id := range m.removeddoctor_diagnose {
			ids = append(ids, id)
		}
		return ids
	case doctor.EdgeDoctorPrescription:
		ids := make([]ent.Value, 0, len(m.removeddoctor_prescription))
		for id := range m.removeddoctor_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DoctorMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DoctorMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DoctorMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Doctor unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DoctorMutation) ResetEdge(name string) error {
	switch name {
	case doctor.EdgeDoctorDiagnose:
		m.ResetDoctorDiagnose()
		return nil
	case doctor.EdgeDoctorPrescription:
		m.ResetDoctorPrescription()
		return nil
	}
	return fmt.Errorf("unknown Doctor edge %s", name)
}

// DrugMutation represents an operation that mutate the Drugs
// nodes in the graph.
type DrugMutation struct {
	config
	op                       Op
	typ                      string
	id                       *int
	_Drug_Name               *string
	clearedFields            map[string]struct{}
	drug_prescription        map[int]struct{}
	removeddrug_prescription map[int]struct{}
	done                     bool
	oldValue                 func(context.Context) (*Drug, error)
}

var _ ent.Mutation = (*DrugMutation)(nil)

// drugOption allows to manage the mutation configuration using functional options.
type drugOption func(*DrugMutation)

// newDrugMutation creates new mutation for $n.Name.
func newDrugMutation(c config, op Op, opts ...drugOption) *DrugMutation {
	m := &DrugMutation{
		config:        c,
		op:            op,
		typ:           TypeDrug,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDrugID sets the id field of the mutation.
func withDrugID(id int) drugOption {
	return func(m *DrugMutation) {
		var (
			err   error
			once  sync.Once
			value *Drug
		)
		m.oldValue = func(ctx context.Context) (*Drug, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Drug.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDrug sets the old Drug of the mutation.
func withDrug(node *Drug) drugOption {
	return func(m *DrugMutation) {
		m.oldValue = func(context.Context) (*Drug, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DrugMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DrugMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DrugMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDrugName sets the Drug_Name field.
func (m *DrugMutation) SetDrugName(s string) {
	m._Drug_Name = &s
}

// DrugName returns the Drug_Name value in the mutation.
func (m *DrugMutation) DrugName() (r string, exists bool) {
	v := m._Drug_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldDrugName returns the old Drug_Name value of the Drug.
// If the Drug object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DrugMutation) OldDrugName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDrugName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDrugName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDrugName: %w", err)
	}
	return oldValue.DrugName, nil
}

// ResetDrugName reset all changes of the "Drug_Name" field.
func (m *DrugMutation) ResetDrugName() {
	m._Drug_Name = nil
}

// AddDrugPrescriptionIDs adds the drug_prescription edge to Prescription by ids.
func (m *DrugMutation) AddDrugPrescriptionIDs(ids ...int) {
	if m.drug_prescription == nil {
		m.drug_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.drug_prescription[ids[i]] = struct{}{}
	}
}

// RemoveDrugPrescriptionIDs removes the drug_prescription edge to Prescription by ids.
func (m *DrugMutation) RemoveDrugPrescriptionIDs(ids ...int) {
	if m.removeddrug_prescription == nil {
		m.removeddrug_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removeddrug_prescription[ids[i]] = struct{}{}
	}
}

// RemovedDrugPrescription returns the removed ids of drug_prescription.
func (m *DrugMutation) RemovedDrugPrescriptionIDs() (ids []int) {
	for id := range m.removeddrug_prescription {
		ids = append(ids, id)
	}
	return
}

// DrugPrescriptionIDs returns the drug_prescription ids in the mutation.
func (m *DrugMutation) DrugPrescriptionIDs() (ids []int) {
	for id := range m.drug_prescription {
		ids = append(ids, id)
	}
	return
}

// ResetDrugPrescription reset all changes of the "drug_prescription" edge.
func (m *DrugMutation) ResetDrugPrescription() {
	m.drug_prescription = nil
	m.removeddrug_prescription = nil
}

// Op returns the operation name.
func (m *DrugMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Drug).
func (m *DrugMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DrugMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Drug_Name != nil {
		fields = append(fields, drug.FieldDrugName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DrugMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case drug.FieldDrugName:
		return m.DrugName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DrugMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case drug.FieldDrugName:
		return m.OldDrugName(ctx)
	}
	return nil, fmt.Errorf("unknown Drug field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DrugMutation) SetField(name string, value ent.Value) error {
	switch name {
	case drug.FieldDrugName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDrugName(v)
		return nil
	}
	return fmt.Errorf("unknown Drug field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DrugMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DrugMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DrugMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Drug numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DrugMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DrugMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DrugMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Drug nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DrugMutation) ResetField(name string) error {
	switch name {
	case drug.FieldDrugName:
		m.ResetDrugName()
		return nil
	}
	return fmt.Errorf("unknown Drug field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DrugMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.drug_prescription != nil {
		edges = append(edges, drug.EdgeDrugPrescription)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DrugMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case drug.EdgeDrugPrescription:
		ids := make([]ent.Value, 0, len(m.drug_prescription))
		for id := range m.drug_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DrugMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removeddrug_prescription != nil {
		edges = append(edges, drug.EdgeDrugPrescription)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DrugMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case drug.EdgeDrugPrescription:
		ids := make([]ent.Value, 0, len(m.removeddrug_prescription))
		for id := range m.removeddrug_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DrugMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DrugMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DrugMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Drug unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DrugMutation) ResetEdge(name string) error {
	switch name {
	case drug.EdgeDrugPrescription:
		m.ResetDrugPrescription()
		return nil
	}
	return fmt.Errorf("unknown Drug edge %s", name)
}

// ExaminationroomMutation represents an operation that mutate the Examinationrooms
// nodes in the graph.
type ExaminationroomMutation struct {
	config
	op                                      Op
	typ                                     string
	id                                      *int
	examinationroom_name                    *string
	clearedFields                           map[string]struct{}
	_Examinationroom_Operativerecord        map[int]struct{}
	removed_Examinationroom_Operativerecord map[int]struct{}
	done                                    bool
	oldValue                                func(context.Context) (*Examinationroom, error)
}

var _ ent.Mutation = (*ExaminationroomMutation)(nil)

// examinationroomOption allows to manage the mutation configuration using functional options.
type examinationroomOption func(*ExaminationroomMutation)

// newExaminationroomMutation creates new mutation for $n.Name.
func newExaminationroomMutation(c config, op Op, opts ...examinationroomOption) *ExaminationroomMutation {
	m := &ExaminationroomMutation{
		config:        c,
		op:            op,
		typ:           TypeExaminationroom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withExaminationroomID sets the id field of the mutation.
func withExaminationroomID(id int) examinationroomOption {
	return func(m *ExaminationroomMutation) {
		var (
			err   error
			once  sync.Once
			value *Examinationroom
		)
		m.oldValue = func(ctx context.Context) (*Examinationroom, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Examinationroom.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withExaminationroom sets the old Examinationroom of the mutation.
func withExaminationroom(node *Examinationroom) examinationroomOption {
	return func(m *ExaminationroomMutation) {
		m.oldValue = func(context.Context) (*Examinationroom, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ExaminationroomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ExaminationroomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ExaminationroomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetExaminationroomName sets the examinationroom_name field.
func (m *ExaminationroomMutation) SetExaminationroomName(s string) {
	m.examinationroom_name = &s
}

// ExaminationroomName returns the examinationroom_name value in the mutation.
func (m *ExaminationroomMutation) ExaminationroomName() (r string, exists bool) {
	v := m.examinationroom_name
	if v == nil {
		return
	}
	return *v, true
}

// OldExaminationroomName returns the old examinationroom_name value of the Examinationroom.
// If the Examinationroom object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ExaminationroomMutation) OldExaminationroomName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldExaminationroomName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldExaminationroomName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExaminationroomName: %w", err)
	}
	return oldValue.ExaminationroomName, nil
}

// ResetExaminationroomName reset all changes of the "examinationroom_name" field.
func (m *ExaminationroomMutation) ResetExaminationroomName() {
	m.examinationroom_name = nil
}

// AddExaminationroomOperativerecordIDs adds the Examinationroom_Operativerecord edge to Operativerecord by ids.
func (m *ExaminationroomMutation) AddExaminationroomOperativerecordIDs(ids ...int) {
	if m._Examinationroom_Operativerecord == nil {
		m._Examinationroom_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m._Examinationroom_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemoveExaminationroomOperativerecordIDs removes the Examinationroom_Operativerecord edge to Operativerecord by ids.
func (m *ExaminationroomMutation) RemoveExaminationroomOperativerecordIDs(ids ...int) {
	if m.removed_Examinationroom_Operativerecord == nil {
		m.removed_Examinationroom_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Examinationroom_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemovedExaminationroomOperativerecord returns the removed ids of Examinationroom_Operativerecord.
func (m *ExaminationroomMutation) RemovedExaminationroomOperativerecordIDs() (ids []int) {
	for id := range m.removed_Examinationroom_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ExaminationroomOperativerecordIDs returns the Examinationroom_Operativerecord ids in the mutation.
func (m *ExaminationroomMutation) ExaminationroomOperativerecordIDs() (ids []int) {
	for id := range m._Examinationroom_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ResetExaminationroomOperativerecord reset all changes of the "Examinationroom_Operativerecord" edge.
func (m *ExaminationroomMutation) ResetExaminationroomOperativerecord() {
	m._Examinationroom_Operativerecord = nil
	m.removed_Examinationroom_Operativerecord = nil
}

// Op returns the operation name.
func (m *ExaminationroomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Examinationroom).
func (m *ExaminationroomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ExaminationroomMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.examinationroom_name != nil {
		fields = append(fields, examinationroom.FieldExaminationroomName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ExaminationroomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case examinationroom.FieldExaminationroomName:
		return m.ExaminationroomName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ExaminationroomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case examinationroom.FieldExaminationroomName:
		return m.OldExaminationroomName(ctx)
	}
	return nil, fmt.Errorf("unknown Examinationroom field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExaminationroomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case examinationroom.FieldExaminationroomName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExaminationroomName(v)
		return nil
	}
	return fmt.Errorf("unknown Examinationroom field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ExaminationroomMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ExaminationroomMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ExaminationroomMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Examinationroom numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ExaminationroomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ExaminationroomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ExaminationroomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Examinationroom nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ExaminationroomMutation) ResetField(name string) error {
	switch name {
	case examinationroom.FieldExaminationroomName:
		m.ResetExaminationroomName()
		return nil
	}
	return fmt.Errorf("unknown Examinationroom field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ExaminationroomMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Examinationroom_Operativerecord != nil {
		edges = append(edges, examinationroom.EdgeExaminationroomOperativerecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ExaminationroomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case examinationroom.EdgeExaminationroomOperativerecord:
		ids := make([]ent.Value, 0, len(m._Examinationroom_Operativerecord))
		for id := range m._Examinationroom_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ExaminationroomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Examinationroom_Operativerecord != nil {
		edges = append(edges, examinationroom.EdgeExaminationroomOperativerecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ExaminationroomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case examinationroom.EdgeExaminationroomOperativerecord:
		ids := make([]ent.Value, 0, len(m.removed_Examinationroom_Operativerecord))
		for id := range m.removed_Examinationroom_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ExaminationroomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ExaminationroomMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ExaminationroomMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Examinationroom unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ExaminationroomMutation) ResetEdge(name string) error {
	switch name {
	case examinationroom.EdgeExaminationroomOperativerecord:
		m.ResetExaminationroomOperativerecord()
		return nil
	}
	return fmt.Errorf("unknown Examinationroom edge %s", name)
}

// FundMutation represents an operation that mutate the Funds
// nodes in the graph.
type FundMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int
	_Fund_Name                 *string
	clearedFields              map[string]struct{}
	_Fund_CoveredPerson        map[int]struct{}
	removed_Fund_CoveredPerson map[int]struct{}
	done                       bool
	oldValue                   func(context.Context) (*Fund, error)
}

var _ ent.Mutation = (*FundMutation)(nil)

// fundOption allows to manage the mutation configuration using functional options.
type fundOption func(*FundMutation)

// newFundMutation creates new mutation for $n.Name.
func newFundMutation(c config, op Op, opts ...fundOption) *FundMutation {
	m := &FundMutation{
		config:        c,
		op:            op,
		typ:           TypeFund,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFundID sets the id field of the mutation.
func withFundID(id int) fundOption {
	return func(m *FundMutation) {
		var (
			err   error
			once  sync.Once
			value *Fund
		)
		m.oldValue = func(ctx context.Context) (*Fund, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Fund.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFund sets the old Fund of the mutation.
func withFund(node *Fund) fundOption {
	return func(m *FundMutation) {
		m.oldValue = func(context.Context) (*Fund, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FundMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FundMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *FundMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetFundName sets the Fund_Name field.
func (m *FundMutation) SetFundName(s string) {
	m._Fund_Name = &s
}

// FundName returns the Fund_Name value in the mutation.
func (m *FundMutation) FundName() (r string, exists bool) {
	v := m._Fund_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldFundName returns the old Fund_Name value of the Fund.
// If the Fund object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *FundMutation) OldFundName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFundName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFundName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFundName: %w", err)
	}
	return oldValue.FundName, nil
}

// ResetFundName reset all changes of the "Fund_Name" field.
func (m *FundMutation) ResetFundName() {
	m._Fund_Name = nil
}

// AddFundCoveredPersonIDs adds the Fund_CoveredPerson edge to CoveredPerson by ids.
func (m *FundMutation) AddFundCoveredPersonIDs(ids ...int) {
	if m._Fund_CoveredPerson == nil {
		m._Fund_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Fund_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveFundCoveredPersonIDs removes the Fund_CoveredPerson edge to CoveredPerson by ids.
func (m *FundMutation) RemoveFundCoveredPersonIDs(ids ...int) {
	if m.removed_Fund_CoveredPerson == nil {
		m.removed_Fund_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Fund_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedFundCoveredPerson returns the removed ids of Fund_CoveredPerson.
func (m *FundMutation) RemovedFundCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Fund_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// FundCoveredPersonIDs returns the Fund_CoveredPerson ids in the mutation.
func (m *FundMutation) FundCoveredPersonIDs() (ids []int) {
	for id := range m._Fund_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetFundCoveredPerson reset all changes of the "Fund_CoveredPerson" edge.
func (m *FundMutation) ResetFundCoveredPerson() {
	m._Fund_CoveredPerson = nil
	m.removed_Fund_CoveredPerson = nil
}

// Op returns the operation name.
func (m *FundMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Fund).
func (m *FundMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *FundMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Fund_Name != nil {
		fields = append(fields, fund.FieldFundName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *FundMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case fund.FieldFundName:
		return m.FundName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *FundMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case fund.FieldFundName:
		return m.OldFundName(ctx)
	}
	return nil, fmt.Errorf("unknown Fund field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FundMutation) SetField(name string, value ent.Value) error {
	switch name {
	case fund.FieldFundName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFundName(v)
		return nil
	}
	return fmt.Errorf("unknown Fund field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *FundMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *FundMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *FundMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Fund numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *FundMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *FundMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *FundMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Fund nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *FundMutation) ResetField(name string) error {
	switch name {
	case fund.FieldFundName:
		m.ResetFundName()
		return nil
	}
	return fmt.Errorf("unknown Fund field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *FundMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Fund_CoveredPerson != nil {
		edges = append(edges, fund.EdgeFundCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *FundMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case fund.EdgeFundCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Fund_CoveredPerson))
		for id := range m._Fund_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *FundMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Fund_CoveredPerson != nil {
		edges = append(edges, fund.EdgeFundCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *FundMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case fund.EdgeFundCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Fund_CoveredPerson))
		for id := range m.removed_Fund_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *FundMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *FundMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *FundMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Fund unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *FundMutation) ResetEdge(name string) error {
	switch name {
	case fund.EdgeFundCoveredPerson:
		m.ResetFundCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown Fund edge %s", name)
}

// GenderMutation represents an operation that mutate the Genders
// nodes in the graph.
type GenderMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Gname            *string
	clearedFields     map[string]struct{}
	fromgender        map[int]struct{}
	removedfromgender map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Gender, error)
}

var _ ent.Mutation = (*GenderMutation)(nil)

// genderOption allows to manage the mutation configuration using functional options.
type genderOption func(*GenderMutation)

// newGenderMutation creates new mutation for $n.Name.
func newGenderMutation(c config, op Op, opts ...genderOption) *GenderMutation {
	m := &GenderMutation{
		config:        c,
		op:            op,
		typ:           TypeGender,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withGenderID sets the id field of the mutation.
func withGenderID(id int) genderOption {
	return func(m *GenderMutation) {
		var (
			err   error
			once  sync.Once
			value *Gender
		)
		m.oldValue = func(ctx context.Context) (*Gender, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Gender.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withGender sets the old Gender of the mutation.
func withGender(node *Gender) genderOption {
	return func(m *GenderMutation) {
		m.oldValue = func(context.Context) (*Gender, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m GenderMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m GenderMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *GenderMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetGname sets the Gname field.
func (m *GenderMutation) SetGname(s string) {
	m._Gname = &s
}

// Gname returns the Gname value in the mutation.
func (m *GenderMutation) Gname() (r string, exists bool) {
	v := m._Gname
	if v == nil {
		return
	}
	return *v, true
}

// OldGname returns the old Gname value of the Gender.
// If the Gender object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *GenderMutation) OldGname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldGname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldGname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGname: %w", err)
	}
	return oldValue.Gname, nil
}

// ResetGname reset all changes of the "Gname" field.
func (m *GenderMutation) ResetGname() {
	m._Gname = nil
}

// AddFromgenderIDs adds the fromgender edge to Patient by ids.
func (m *GenderMutation) AddFromgenderIDs(ids ...int) {
	if m.fromgender == nil {
		m.fromgender = make(map[int]struct{})
	}
	for i := range ids {
		m.fromgender[ids[i]] = struct{}{}
	}
}

// RemoveFromgenderIDs removes the fromgender edge to Patient by ids.
func (m *GenderMutation) RemoveFromgenderIDs(ids ...int) {
	if m.removedfromgender == nil {
		m.removedfromgender = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromgender[ids[i]] = struct{}{}
	}
}

// RemovedFromgender returns the removed ids of fromgender.
func (m *GenderMutation) RemovedFromgenderIDs() (ids []int) {
	for id := range m.removedfromgender {
		ids = append(ids, id)
	}
	return
}

// FromgenderIDs returns the fromgender ids in the mutation.
func (m *GenderMutation) FromgenderIDs() (ids []int) {
	for id := range m.fromgender {
		ids = append(ids, id)
	}
	return
}

// ResetFromgender reset all changes of the "fromgender" edge.
func (m *GenderMutation) ResetFromgender() {
	m.fromgender = nil
	m.removedfromgender = nil
}

// Op returns the operation name.
func (m *GenderMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Gender).
func (m *GenderMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *GenderMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Gname != nil {
		fields = append(fields, gender.FieldGname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *GenderMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case gender.FieldGname:
		return m.Gname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *GenderMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case gender.FieldGname:
		return m.OldGname(ctx)
	}
	return nil, fmt.Errorf("unknown Gender field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) SetField(name string, value ent.Value) error {
	switch name {
	case gender.FieldGname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGname(v)
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *GenderMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *GenderMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *GenderMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *GenderMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *GenderMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *GenderMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Gender nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *GenderMutation) ResetField(name string) error {
	switch name {
	case gender.FieldGname:
		m.ResetGname()
		return nil
	}
	return fmt.Errorf("unknown Gender field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *GenderMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fromgender != nil {
		edges = append(edges, gender.EdgeFromgender)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *GenderMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeFromgender:
		ids := make([]ent.Value, 0, len(m.fromgender))
		for id := range m.fromgender {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *GenderMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfromgender != nil {
		edges = append(edges, gender.EdgeFromgender)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *GenderMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case gender.EdgeFromgender:
		ids := make([]ent.Value, 0, len(m.removedfromgender))
		for id := range m.removedfromgender {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *GenderMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *GenderMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *GenderMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Gender unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *GenderMutation) ResetEdge(name string) error {
	switch name {
	case gender.EdgeFromgender:
		m.ResetFromgender()
		return nil
	}
	return fmt.Errorf("unknown Gender edge %s", name)
}

// MedicalMutation represents an operation that mutate the Medicals
// nodes in the graph.
type MedicalMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Medical_Name     *string
	_Medical_Email    *string
	_Medical_Password *string
	_Medical_Tel      *string
	clearedFields     map[string]struct{}
	done              bool
	oldValue          func(context.Context) (*Medical, error)
}

var _ ent.Mutation = (*MedicalMutation)(nil)

// medicalOption allows to manage the mutation configuration using functional options.
type medicalOption func(*MedicalMutation)

// newMedicalMutation creates new mutation for $n.Name.
func newMedicalMutation(c config, op Op, opts ...medicalOption) *MedicalMutation {
	m := &MedicalMutation{
		config:        c,
		op:            op,
		typ:           TypeMedical,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMedicalID sets the id field of the mutation.
func withMedicalID(id int) medicalOption {
	return func(m *MedicalMutation) {
		var (
			err   error
			once  sync.Once
			value *Medical
		)
		m.oldValue = func(ctx context.Context) (*Medical, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Medical.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMedical sets the old Medical of the mutation.
func withMedical(node *Medical) medicalOption {
	return func(m *MedicalMutation) {
		m.oldValue = func(context.Context) (*Medical, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MedicalMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MedicalMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *MedicalMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetMedicalName sets the Medical_Name field.
func (m *MedicalMutation) SetMedicalName(s string) {
	m._Medical_Name = &s
}

// MedicalName returns the Medical_Name value in the mutation.
func (m *MedicalMutation) MedicalName() (r string, exists bool) {
	v := m._Medical_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalName returns the old Medical_Name value of the Medical.
// If the Medical object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalMutation) OldMedicalName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalName: %w", err)
	}
	return oldValue.MedicalName, nil
}

// ResetMedicalName reset all changes of the "Medical_Name" field.
func (m *MedicalMutation) ResetMedicalName() {
	m._Medical_Name = nil
}

// SetMedicalEmail sets the Medical_Email field.
func (m *MedicalMutation) SetMedicalEmail(s string) {
	m._Medical_Email = &s
}

// MedicalEmail returns the Medical_Email value in the mutation.
func (m *MedicalMutation) MedicalEmail() (r string, exists bool) {
	v := m._Medical_Email
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalEmail returns the old Medical_Email value of the Medical.
// If the Medical object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalMutation) OldMedicalEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalEmail: %w", err)
	}
	return oldValue.MedicalEmail, nil
}

// ResetMedicalEmail reset all changes of the "Medical_Email" field.
func (m *MedicalMutation) ResetMedicalEmail() {
	m._Medical_Email = nil
}

// SetMedicalPassword sets the Medical_Password field.
func (m *MedicalMutation) SetMedicalPassword(s string) {
	m._Medical_Password = &s
}

// MedicalPassword returns the Medical_Password value in the mutation.
func (m *MedicalMutation) MedicalPassword() (r string, exists bool) {
	v := m._Medical_Password
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalPassword returns the old Medical_Password value of the Medical.
// If the Medical object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalMutation) OldMedicalPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalPassword: %w", err)
	}
	return oldValue.MedicalPassword, nil
}

// ResetMedicalPassword reset all changes of the "Medical_Password" field.
func (m *MedicalMutation) ResetMedicalPassword() {
	m._Medical_Password = nil
}

// SetMedicalTel sets the Medical_Tel field.
func (m *MedicalMutation) SetMedicalTel(s string) {
	m._Medical_Tel = &s
}

// MedicalTel returns the Medical_Tel value in the mutation.
func (m *MedicalMutation) MedicalTel() (r string, exists bool) {
	v := m._Medical_Tel
	if v == nil {
		return
	}
	return *v, true
}

// OldMedicalTel returns the old Medical_Tel value of the Medical.
// If the Medical object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *MedicalMutation) OldMedicalTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldMedicalTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldMedicalTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMedicalTel: %w", err)
	}
	return oldValue.MedicalTel, nil
}

// ResetMedicalTel reset all changes of the "Medical_Tel" field.
func (m *MedicalMutation) ResetMedicalTel() {
	m._Medical_Tel = nil
}

// Op returns the operation name.
func (m *MedicalMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Medical).
func (m *MedicalMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *MedicalMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Medical_Name != nil {
		fields = append(fields, medical.FieldMedicalName)
	}
	if m._Medical_Email != nil {
		fields = append(fields, medical.FieldMedicalEmail)
	}
	if m._Medical_Password != nil {
		fields = append(fields, medical.FieldMedicalPassword)
	}
	if m._Medical_Tel != nil {
		fields = append(fields, medical.FieldMedicalTel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *MedicalMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case medical.FieldMedicalName:
		return m.MedicalName()
	case medical.FieldMedicalEmail:
		return m.MedicalEmail()
	case medical.FieldMedicalPassword:
		return m.MedicalPassword()
	case medical.FieldMedicalTel:
		return m.MedicalTel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *MedicalMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case medical.FieldMedicalName:
		return m.OldMedicalName(ctx)
	case medical.FieldMedicalEmail:
		return m.OldMedicalEmail(ctx)
	case medical.FieldMedicalPassword:
		return m.OldMedicalPassword(ctx)
	case medical.FieldMedicalTel:
		return m.OldMedicalTel(ctx)
	}
	return nil, fmt.Errorf("unknown Medical field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalMutation) SetField(name string, value ent.Value) error {
	switch name {
	case medical.FieldMedicalName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalName(v)
		return nil
	case medical.FieldMedicalEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalEmail(v)
		return nil
	case medical.FieldMedicalPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalPassword(v)
		return nil
	case medical.FieldMedicalTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMedicalTel(v)
		return nil
	}
	return fmt.Errorf("unknown Medical field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *MedicalMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *MedicalMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *MedicalMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Medical numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *MedicalMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *MedicalMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *MedicalMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Medical nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *MedicalMutation) ResetField(name string) error {
	switch name {
	case medical.FieldMedicalName:
		m.ResetMedicalName()
		return nil
	case medical.FieldMedicalEmail:
		m.ResetMedicalEmail()
		return nil
	case medical.FieldMedicalPassword:
		m.ResetMedicalPassword()
		return nil
	case medical.FieldMedicalTel:
		m.ResetMedicalTel()
		return nil
	}
	return fmt.Errorf("unknown Medical field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *MedicalMutation) AddedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *MedicalMutation) AddedIDs(name string) []ent.Value {
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *MedicalMutation) RemovedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *MedicalMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *MedicalMutation) ClearedEdges() []string {
	edges := make([]string, 0, 0)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *MedicalMutation) EdgeCleared(name string) bool {
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *MedicalMutation) ClearEdge(name string) error {
	return fmt.Errorf("unknown Medical unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *MedicalMutation) ResetEdge(name string) error {
	return fmt.Errorf("unknown Medical edge %s", name)
}

// NurseMutation represents an operation that mutate the Nurses
// nodes in the graph.
type NurseMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	nurse_name                    *string
	nurse_email                   *string
	nurse_password                *string
	nurse_tel                     *string
	clearedFields                 map[string]struct{}
	fromnurse                     map[int]struct{}
	removedfromnurse              map[int]struct{}
	nurse_prescription            map[int]struct{}
	removednurse_prescription     map[int]struct{}
	_Nurse_Operativerecord        map[int]struct{}
	removed_Nurse_Operativerecord map[int]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Nurse, error)
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows to manage the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for $n.Name.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the id field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetNurseName sets the nurse_name field.
func (m *NurseMutation) SetNurseName(s string) {
	m.nurse_name = &s
}

// NurseName returns the nurse_name value in the mutation.
func (m *NurseMutation) NurseName() (r string, exists bool) {
	v := m.nurse_name
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseName returns the old nurse_name value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseName: %w", err)
	}
	return oldValue.NurseName, nil
}

// ResetNurseName reset all changes of the "nurse_name" field.
func (m *NurseMutation) ResetNurseName() {
	m.nurse_name = nil
}

// SetNurseEmail sets the nurse_email field.
func (m *NurseMutation) SetNurseEmail(s string) {
	m.nurse_email = &s
}

// NurseEmail returns the nurse_email value in the mutation.
func (m *NurseMutation) NurseEmail() (r string, exists bool) {
	v := m.nurse_email
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseEmail returns the old nurse_email value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseEmail: %w", err)
	}
	return oldValue.NurseEmail, nil
}

// ResetNurseEmail reset all changes of the "nurse_email" field.
func (m *NurseMutation) ResetNurseEmail() {
	m.nurse_email = nil
}

// SetNursePassword sets the nurse_password field.
func (m *NurseMutation) SetNursePassword(s string) {
	m.nurse_password = &s
}

// NursePassword returns the nurse_password value in the mutation.
func (m *NurseMutation) NursePassword() (r string, exists bool) {
	v := m.nurse_password
	if v == nil {
		return
	}
	return *v, true
}

// OldNursePassword returns the old nurse_password value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNursePassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursePassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursePassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursePassword: %w", err)
	}
	return oldValue.NursePassword, nil
}

// ResetNursePassword reset all changes of the "nurse_password" field.
func (m *NurseMutation) ResetNursePassword() {
	m.nurse_password = nil
}

// SetNurseTel sets the nurse_tel field.
func (m *NurseMutation) SetNurseTel(s string) {
	m.nurse_tel = &s
}

// NurseTel returns the nurse_tel value in the mutation.
func (m *NurseMutation) NurseTel() (r string, exists bool) {
	v := m.nurse_tel
	if v == nil {
		return
	}
	return *v, true
}

// OldNurseTel returns the old nurse_tel value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNurseTel(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNurseTel is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNurseTel requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNurseTel: %w", err)
	}
	return oldValue.NurseTel, nil
}

// ResetNurseTel reset all changes of the "nurse_tel" field.
func (m *NurseMutation) ResetNurseTel() {
	m.nurse_tel = nil
}

// AddFromnurseIDs adds the fromnurse edge to Rent by ids.
func (m *NurseMutation) AddFromnurseIDs(ids ...int) {
	if m.fromnurse == nil {
		m.fromnurse = make(map[int]struct{})
	}
	for i := range ids {
		m.fromnurse[ids[i]] = struct{}{}
	}
}

// RemoveFromnurseIDs removes the fromnurse edge to Rent by ids.
func (m *NurseMutation) RemoveFromnurseIDs(ids ...int) {
	if m.removedfromnurse == nil {
		m.removedfromnurse = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromnurse[ids[i]] = struct{}{}
	}
}

// RemovedFromnurse returns the removed ids of fromnurse.
func (m *NurseMutation) RemovedFromnurseIDs() (ids []int) {
	for id := range m.removedfromnurse {
		ids = append(ids, id)
	}
	return
}

// FromnurseIDs returns the fromnurse ids in the mutation.
func (m *NurseMutation) FromnurseIDs() (ids []int) {
	for id := range m.fromnurse {
		ids = append(ids, id)
	}
	return
}

// ResetFromnurse reset all changes of the "fromnurse" edge.
func (m *NurseMutation) ResetFromnurse() {
	m.fromnurse = nil
	m.removedfromnurse = nil
}

// AddNursePrescriptionIDs adds the nurse_prescription edge to Prescription by ids.
func (m *NurseMutation) AddNursePrescriptionIDs(ids ...int) {
	if m.nurse_prescription == nil {
		m.nurse_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.nurse_prescription[ids[i]] = struct{}{}
	}
}

// RemoveNursePrescriptionIDs removes the nurse_prescription edge to Prescription by ids.
func (m *NurseMutation) RemoveNursePrescriptionIDs(ids ...int) {
	if m.removednurse_prescription == nil {
		m.removednurse_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removednurse_prescription[ids[i]] = struct{}{}
	}
}

// RemovedNursePrescription returns the removed ids of nurse_prescription.
func (m *NurseMutation) RemovedNursePrescriptionIDs() (ids []int) {
	for id := range m.removednurse_prescription {
		ids = append(ids, id)
	}
	return
}

// NursePrescriptionIDs returns the nurse_prescription ids in the mutation.
func (m *NurseMutation) NursePrescriptionIDs() (ids []int) {
	for id := range m.nurse_prescription {
		ids = append(ids, id)
	}
	return
}

// ResetNursePrescription reset all changes of the "nurse_prescription" edge.
func (m *NurseMutation) ResetNursePrescription() {
	m.nurse_prescription = nil
	m.removednurse_prescription = nil
}

// AddNurseOperativerecordIDs adds the Nurse_Operativerecord edge to Operativerecord by ids.
func (m *NurseMutation) AddNurseOperativerecordIDs(ids ...int) {
	if m._Nurse_Operativerecord == nil {
		m._Nurse_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m._Nurse_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemoveNurseOperativerecordIDs removes the Nurse_Operativerecord edge to Operativerecord by ids.
func (m *NurseMutation) RemoveNurseOperativerecordIDs(ids ...int) {
	if m.removed_Nurse_Operativerecord == nil {
		m.removed_Nurse_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Nurse_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemovedNurseOperativerecord returns the removed ids of Nurse_Operativerecord.
func (m *NurseMutation) RemovedNurseOperativerecordIDs() (ids []int) {
	for id := range m.removed_Nurse_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// NurseOperativerecordIDs returns the Nurse_Operativerecord ids in the mutation.
func (m *NurseMutation) NurseOperativerecordIDs() (ids []int) {
	for id := range m._Nurse_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ResetNurseOperativerecord reset all changes of the "Nurse_Operativerecord" edge.
func (m *NurseMutation) ResetNurseOperativerecord() {
	m._Nurse_Operativerecord = nil
	m.removed_Nurse_Operativerecord = nil
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.nurse_name != nil {
		fields = append(fields, nurse.FieldNurseName)
	}
	if m.nurse_email != nil {
		fields = append(fields, nurse.FieldNurseEmail)
	}
	if m.nurse_password != nil {
		fields = append(fields, nurse.FieldNursePassword)
	}
	if m.nurse_tel != nil {
		fields = append(fields, nurse.FieldNurseTel)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldNurseName:
		return m.NurseName()
	case nurse.FieldNurseEmail:
		return m.NurseEmail()
	case nurse.FieldNursePassword:
		return m.NursePassword()
	case nurse.FieldNurseTel:
		return m.NurseTel()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldNurseName:
		return m.OldNurseName(ctx)
	case nurse.FieldNurseEmail:
		return m.OldNurseEmail(ctx)
	case nurse.FieldNursePassword:
		return m.OldNursePassword(ctx)
	case nurse.FieldNurseTel:
		return m.OldNurseTel(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldNurseName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseName(v)
		return nil
	case nurse.FieldNurseEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseEmail(v)
		return nil
	case nurse.FieldNursePassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursePassword(v)
		return nil
	case nurse.FieldNurseTel:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNurseTel(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldNurseName:
		m.ResetNurseName()
		return nil
	case nurse.FieldNurseEmail:
		m.ResetNurseEmail()
		return nil
	case nurse.FieldNursePassword:
		m.ResetNursePassword()
		return nil
	case nurse.FieldNurseTel:
		m.ResetNurseTel()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.fromnurse != nil {
		edges = append(edges, nurse.EdgeFromnurse)
	}
	if m.nurse_prescription != nil {
		edges = append(edges, nurse.EdgeNursePrescription)
	}
	if m._Nurse_Operativerecord != nil {
		edges = append(edges, nurse.EdgeNurseOperativerecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeFromnurse:
		ids := make([]ent.Value, 0, len(m.fromnurse))
		for id := range m.fromnurse {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNursePrescription:
		ids := make([]ent.Value, 0, len(m.nurse_prescription))
		for id := range m.nurse_prescription {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseOperativerecord:
		ids := make([]ent.Value, 0, len(m._Nurse_Operativerecord))
		for id := range m._Nurse_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfromnurse != nil {
		edges = append(edges, nurse.EdgeFromnurse)
	}
	if m.removednurse_prescription != nil {
		edges = append(edges, nurse.EdgeNursePrescription)
	}
	if m.removed_Nurse_Operativerecord != nil {
		edges = append(edges, nurse.EdgeNurseOperativerecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeFromnurse:
		ids := make([]ent.Value, 0, len(m.removedfromnurse))
		for id := range m.removedfromnurse {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNursePrescription:
		ids := make([]ent.Value, 0, len(m.removednurse_prescription))
		for id := range m.removednurse_prescription {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeNurseOperativerecord:
		ids := make([]ent.Value, 0, len(m.removed_Nurse_Operativerecord))
		for id := range m.removed_Nurse_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeFromnurse:
		m.ResetFromnurse()
		return nil
	case nurse.EdgeNursePrescription:
		m.ResetNursePrescription()
		return nil
	case nurse.EdgeNurseOperativerecord:
		m.ResetNurseOperativerecord()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// OperativeMutation represents an operation that mutate the Operatives
// nodes in the graph.
type OperativeMutation struct {
	config
	op                                Op
	typ                               string
	id                                *int
	operative_Name                    *string
	clearedFields                     map[string]struct{}
	_Operative_Operativerecord        map[int]struct{}
	removed_Operative_Operativerecord map[int]struct{}
	done                              bool
	oldValue                          func(context.Context) (*Operative, error)
}

var _ ent.Mutation = (*OperativeMutation)(nil)

// operativeOption allows to manage the mutation configuration using functional options.
type operativeOption func(*OperativeMutation)

// newOperativeMutation creates new mutation for $n.Name.
func newOperativeMutation(c config, op Op, opts ...operativeOption) *OperativeMutation {
	m := &OperativeMutation{
		config:        c,
		op:            op,
		typ:           TypeOperative,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperativeID sets the id field of the mutation.
func withOperativeID(id int) operativeOption {
	return func(m *OperativeMutation) {
		var (
			err   error
			once  sync.Once
			value *Operative
		)
		m.oldValue = func(ctx context.Context) (*Operative, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operative.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperative sets the old Operative of the mutation.
func withOperative(node *Operative) operativeOption {
	return func(m *OperativeMutation) {
		m.oldValue = func(context.Context) (*Operative, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperativeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperativeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OperativeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperativeName sets the operative_Name field.
func (m *OperativeMutation) SetOperativeName(s string) {
	m.operative_Name = &s
}

// OperativeName returns the operative_Name value in the mutation.
func (m *OperativeMutation) OperativeName() (r string, exists bool) {
	v := m.operative_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldOperativeName returns the old operative_Name value of the Operative.
// If the Operative object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperativeMutation) OldOperativeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperativeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperativeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperativeName: %w", err)
	}
	return oldValue.OperativeName, nil
}

// ResetOperativeName reset all changes of the "operative_Name" field.
func (m *OperativeMutation) ResetOperativeName() {
	m.operative_Name = nil
}

// AddOperativeOperativerecordIDs adds the Operative_Operativerecord edge to Operativerecord by ids.
func (m *OperativeMutation) AddOperativeOperativerecordIDs(ids ...int) {
	if m._Operative_Operativerecord == nil {
		m._Operative_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m._Operative_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemoveOperativeOperativerecordIDs removes the Operative_Operativerecord edge to Operativerecord by ids.
func (m *OperativeMutation) RemoveOperativeOperativerecordIDs(ids ...int) {
	if m.removed_Operative_Operativerecord == nil {
		m.removed_Operative_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Operative_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemovedOperativeOperativerecord returns the removed ids of Operative_Operativerecord.
func (m *OperativeMutation) RemovedOperativeOperativerecordIDs() (ids []int) {
	for id := range m.removed_Operative_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// OperativeOperativerecordIDs returns the Operative_Operativerecord ids in the mutation.
func (m *OperativeMutation) OperativeOperativerecordIDs() (ids []int) {
	for id := range m._Operative_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ResetOperativeOperativerecord reset all changes of the "Operative_Operativerecord" edge.
func (m *OperativeMutation) ResetOperativeOperativerecord() {
	m._Operative_Operativerecord = nil
	m.removed_Operative_Operativerecord = nil
}

// Op returns the operation name.
func (m *OperativeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Operative).
func (m *OperativeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OperativeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.operative_Name != nil {
		fields = append(fields, operative.FieldOperativeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OperativeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operative.FieldOperativeName:
		return m.OperativeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OperativeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operative.FieldOperativeName:
		return m.OldOperativeName(ctx)
	}
	return nil, fmt.Errorf("unknown Operative field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operative.FieldOperativeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperativeName(v)
		return nil
	}
	return fmt.Errorf("unknown Operative field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OperativeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OperativeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operative numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OperativeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OperativeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperativeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operative nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OperativeMutation) ResetField(name string) error {
	switch name {
	case operative.FieldOperativeName:
		m.ResetOperativeName()
		return nil
	}
	return fmt.Errorf("unknown Operative field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OperativeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Operative_Operativerecord != nil {
		edges = append(edges, operative.EdgeOperativeOperativerecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OperativeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operative.EdgeOperativeOperativerecord:
		ids := make([]ent.Value, 0, len(m._Operative_Operativerecord))
		for id := range m._Operative_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OperativeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Operative_Operativerecord != nil {
		edges = append(edges, operative.EdgeOperativeOperativerecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OperativeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case operative.EdgeOperativeOperativerecord:
		ids := make([]ent.Value, 0, len(m.removed_Operative_Operativerecord))
		for id := range m.removed_Operative_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OperativeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OperativeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OperativeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Operative unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OperativeMutation) ResetEdge(name string) error {
	switch name {
	case operative.EdgeOperativeOperativerecord:
		m.ResetOperativeOperativerecord()
		return nil
	}
	return fmt.Errorf("unknown Operative edge %s", name)
}

// OperativerecordMutation represents an operation that mutate the Operativerecords
// nodes in the graph.
type OperativerecordMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int
	_OperativeTime          *time.Time
	clearedFields           map[string]struct{}
	_Examinationroom        *int
	cleared_Examinationroom bool
	_Nurse                  *int
	cleared_Nurse           bool
	_Operative              *int
	cleared_Operative       bool
	_Tool                   *int
	cleared_Tool            bool
	done                    bool
	oldValue                func(context.Context) (*Operativerecord, error)
}

var _ ent.Mutation = (*OperativerecordMutation)(nil)

// operativerecordOption allows to manage the mutation configuration using functional options.
type operativerecordOption func(*OperativerecordMutation)

// newOperativerecordMutation creates new mutation for $n.Name.
func newOperativerecordMutation(c config, op Op, opts ...operativerecordOption) *OperativerecordMutation {
	m := &OperativerecordMutation{
		config:        c,
		op:            op,
		typ:           TypeOperativerecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withOperativerecordID sets the id field of the mutation.
func withOperativerecordID(id int) operativerecordOption {
	return func(m *OperativerecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Operativerecord
		)
		m.oldValue = func(ctx context.Context) (*Operativerecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Operativerecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withOperativerecord sets the old Operativerecord of the mutation.
func withOperativerecord(node *Operativerecord) operativerecordOption {
	return func(m *OperativerecordMutation) {
		m.oldValue = func(context.Context) (*Operativerecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m OperativerecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m OperativerecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *OperativerecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetOperativeTime sets the OperativeTime field.
func (m *OperativerecordMutation) SetOperativeTime(t time.Time) {
	m._OperativeTime = &t
}

// OperativeTime returns the OperativeTime value in the mutation.
func (m *OperativerecordMutation) OperativeTime() (r time.Time, exists bool) {
	v := m._OperativeTime
	if v == nil {
		return
	}
	return *v, true
}

// OldOperativeTime returns the old OperativeTime value of the Operativerecord.
// If the Operativerecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *OperativerecordMutation) OldOperativeTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOperativeTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOperativeTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOperativeTime: %w", err)
	}
	return oldValue.OperativeTime, nil
}

// ResetOperativeTime reset all changes of the "OperativeTime" field.
func (m *OperativerecordMutation) ResetOperativeTime() {
	m._OperativeTime = nil
}

// SetExaminationroomID sets the Examinationroom edge to Examinationroom by id.
func (m *OperativerecordMutation) SetExaminationroomID(id int) {
	m._Examinationroom = &id
}

// ClearExaminationroom clears the Examinationroom edge to Examinationroom.
func (m *OperativerecordMutation) ClearExaminationroom() {
	m.cleared_Examinationroom = true
}

// ExaminationroomCleared returns if the edge Examinationroom was cleared.
func (m *OperativerecordMutation) ExaminationroomCleared() bool {
	return m.cleared_Examinationroom
}

// ExaminationroomID returns the Examinationroom id in the mutation.
func (m *OperativerecordMutation) ExaminationroomID() (id int, exists bool) {
	if m._Examinationroom != nil {
		return *m._Examinationroom, true
	}
	return
}

// ExaminationroomIDs returns the Examinationroom ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ExaminationroomID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) ExaminationroomIDs() (ids []int) {
	if id := m._Examinationroom; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetExaminationroom reset all changes of the "Examinationroom" edge.
func (m *OperativerecordMutation) ResetExaminationroom() {
	m._Examinationroom = nil
	m.cleared_Examinationroom = false
}

// SetNurseID sets the Nurse edge to Nurse by id.
func (m *OperativerecordMutation) SetNurseID(id int) {
	m._Nurse = &id
}

// ClearNurse clears the Nurse edge to Nurse.
func (m *OperativerecordMutation) ClearNurse() {
	m.cleared_Nurse = true
}

// NurseCleared returns if the edge Nurse was cleared.
func (m *OperativerecordMutation) NurseCleared() bool {
	return m.cleared_Nurse
}

// NurseID returns the Nurse id in the mutation.
func (m *OperativerecordMutation) NurseID() (id int, exists bool) {
	if m._Nurse != nil {
		return *m._Nurse, true
	}
	return
}

// NurseIDs returns the Nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) NurseIDs() (ids []int) {
	if id := m._Nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "Nurse" edge.
func (m *OperativerecordMutation) ResetNurse() {
	m._Nurse = nil
	m.cleared_Nurse = false
}

// SetOperativeID sets the Operative edge to Operative by id.
func (m *OperativerecordMutation) SetOperativeID(id int) {
	m._Operative = &id
}

// ClearOperative clears the Operative edge to Operative.
func (m *OperativerecordMutation) ClearOperative() {
	m.cleared_Operative = true
}

// OperativeCleared returns if the edge Operative was cleared.
func (m *OperativerecordMutation) OperativeCleared() bool {
	return m.cleared_Operative
}

// OperativeID returns the Operative id in the mutation.
func (m *OperativerecordMutation) OperativeID() (id int, exists bool) {
	if m._Operative != nil {
		return *m._Operative, true
	}
	return
}

// OperativeIDs returns the Operative ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// OperativeID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) OperativeIDs() (ids []int) {
	if id := m._Operative; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOperative reset all changes of the "Operative" edge.
func (m *OperativerecordMutation) ResetOperative() {
	m._Operative = nil
	m.cleared_Operative = false
}

// SetToolID sets the Tool edge to Tool by id.
func (m *OperativerecordMutation) SetToolID(id int) {
	m._Tool = &id
}

// ClearTool clears the Tool edge to Tool.
func (m *OperativerecordMutation) ClearTool() {
	m.cleared_Tool = true
}

// ToolCleared returns if the edge Tool was cleared.
func (m *OperativerecordMutation) ToolCleared() bool {
	return m.cleared_Tool
}

// ToolID returns the Tool id in the mutation.
func (m *OperativerecordMutation) ToolID() (id int, exists bool) {
	if m._Tool != nil {
		return *m._Tool, true
	}
	return
}

// ToolIDs returns the Tool ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// ToolID instead. It exists only for internal usage by the builders.
func (m *OperativerecordMutation) ToolIDs() (ids []int) {
	if id := m._Tool; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTool reset all changes of the "Tool" edge.
func (m *OperativerecordMutation) ResetTool() {
	m._Tool = nil
	m.cleared_Tool = false
}

// Op returns the operation name.
func (m *OperativerecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Operativerecord).
func (m *OperativerecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *OperativerecordMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._OperativeTime != nil {
		fields = append(fields, operativerecord.FieldOperativeTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *OperativerecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case operativerecord.FieldOperativeTime:
		return m.OperativeTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *OperativerecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case operativerecord.FieldOperativeTime:
		return m.OldOperativeTime(ctx)
	}
	return nil, fmt.Errorf("unknown Operativerecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativerecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case operativerecord.FieldOperativeTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOperativeTime(v)
		return nil
	}
	return fmt.Errorf("unknown Operativerecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *OperativerecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *OperativerecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *OperativerecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Operativerecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *OperativerecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *OperativerecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *OperativerecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Operativerecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *OperativerecordMutation) ResetField(name string) error {
	switch name {
	case operativerecord.FieldOperativeTime:
		m.ResetOperativeTime()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *OperativerecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m._Examinationroom != nil {
		edges = append(edges, operativerecord.EdgeExaminationroom)
	}
	if m._Nurse != nil {
		edges = append(edges, operativerecord.EdgeNurse)
	}
	if m._Operative != nil {
		edges = append(edges, operativerecord.EdgeOperative)
	}
	if m._Tool != nil {
		edges = append(edges, operativerecord.EdgeTool)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *OperativerecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case operativerecord.EdgeExaminationroom:
		if id := m._Examinationroom; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeNurse:
		if id := m._Nurse; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeOperative:
		if id := m._Operative; id != nil {
			return []ent.Value{*id}
		}
	case operativerecord.EdgeTool:
		if id := m._Tool; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *OperativerecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *OperativerecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *OperativerecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleared_Examinationroom {
		edges = append(edges, operativerecord.EdgeExaminationroom)
	}
	if m.cleared_Nurse {
		edges = append(edges, operativerecord.EdgeNurse)
	}
	if m.cleared_Operative {
		edges = append(edges, operativerecord.EdgeOperative)
	}
	if m.cleared_Tool {
		edges = append(edges, operativerecord.EdgeTool)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *OperativerecordMutation) EdgeCleared(name string) bool {
	switch name {
	case operativerecord.EdgeExaminationroom:
		return m.cleared_Examinationroom
	case operativerecord.EdgeNurse:
		return m.cleared_Nurse
	case operativerecord.EdgeOperative:
		return m.cleared_Operative
	case operativerecord.EdgeTool:
		return m.cleared_Tool
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *OperativerecordMutation) ClearEdge(name string) error {
	switch name {
	case operativerecord.EdgeExaminationroom:
		m.ClearExaminationroom()
		return nil
	case operativerecord.EdgeNurse:
		m.ClearNurse()
		return nil
	case operativerecord.EdgeOperative:
		m.ClearOperative()
		return nil
	case operativerecord.EdgeTool:
		m.ClearTool()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *OperativerecordMutation) ResetEdge(name string) error {
	switch name {
	case operativerecord.EdgeExaminationroom:
		m.ResetExaminationroom()
		return nil
	case operativerecord.EdgeNurse:
		m.ResetNurse()
		return nil
	case operativerecord.EdgeOperative:
		m.ResetOperative()
		return nil
	case operativerecord.EdgeTool:
		m.ResetTool()
		return nil
	}
	return fmt.Errorf("unknown Operativerecord edge %s", name)
}

// PatientMutation represents an operation that mutate the Patients
// nodes in the graph.
type PatientMutation struct {
	config
	op                            Op
	typ                           string
	id                            *int
	_Patient_name                 *string
	_Patient_age                  *int
	add_Patient_age               *int
	_Patient_weight               *float64
	add_Patient_weight            *float64
	_Patient_height               *float64
	add_Patient_height            *float64
	clearedFields                 map[string]struct{}
	gender                        *int
	clearedgender                 bool
	prefix                        *int
	clearedprefix                 bool
	bloodtype                     *int
	clearedbloodtype              bool
	frompatient                   *int
	clearedfrompatient            bool
	_Patient_CoveredPerson        map[int]struct{}
	removed_Patient_CoveredPerson map[int]struct{}
	patient_diagnose              map[int]struct{}
	removedpatient_diagnose       map[int]struct{}
	patient_prescription          map[int]struct{}
	removedpatient_prescription   map[int]struct{}
	done                          bool
	oldValue                      func(context.Context) (*Patient, error)
}

var _ ent.Mutation = (*PatientMutation)(nil)

// patientOption allows to manage the mutation configuration using functional options.
type patientOption func(*PatientMutation)

// newPatientMutation creates new mutation for $n.Name.
func newPatientMutation(c config, op Op, opts ...patientOption) *PatientMutation {
	m := &PatientMutation{
		config:        c,
		op:            op,
		typ:           TypePatient,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientID sets the id field of the mutation.
func withPatientID(id int) patientOption {
	return func(m *PatientMutation) {
		var (
			err   error
			once  sync.Once
			value *Patient
		)
		m.oldValue = func(ctx context.Context) (*Patient, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patient.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatient sets the old Patient of the mutation.
func withPatient(node *Patient) patientOption {
	return func(m *PatientMutation) {
		m.oldValue = func(context.Context) (*Patient, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPatientName sets the Patient_name field.
func (m *PatientMutation) SetPatientName(s string) {
	m._Patient_name = &s
}

// PatientName returns the Patient_name value in the mutation.
func (m *PatientMutation) PatientName() (r string, exists bool) {
	v := m._Patient_name
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientName returns the old Patient_name value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientName: %w", err)
	}
	return oldValue.PatientName, nil
}

// ResetPatientName reset all changes of the "Patient_name" field.
func (m *PatientMutation) ResetPatientName() {
	m._Patient_name = nil
}

// SetPatientAge sets the Patient_age field.
func (m *PatientMutation) SetPatientAge(i int) {
	m._Patient_age = &i
	m.add_Patient_age = nil
}

// PatientAge returns the Patient_age value in the mutation.
func (m *PatientMutation) PatientAge() (r int, exists bool) {
	v := m._Patient_age
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientAge returns the old Patient_age value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientAge(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientAge is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientAge requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientAge: %w", err)
	}
	return oldValue.PatientAge, nil
}

// AddPatientAge adds i to Patient_age.
func (m *PatientMutation) AddPatientAge(i int) {
	if m.add_Patient_age != nil {
		*m.add_Patient_age += i
	} else {
		m.add_Patient_age = &i
	}
}

// AddedPatientAge returns the value that was added to the Patient_age field in this mutation.
func (m *PatientMutation) AddedPatientAge() (r int, exists bool) {
	v := m.add_Patient_age
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientAge reset all changes of the "Patient_age" field.
func (m *PatientMutation) ResetPatientAge() {
	m._Patient_age = nil
	m.add_Patient_age = nil
}

// SetPatientWeight sets the Patient_weight field.
func (m *PatientMutation) SetPatientWeight(f float64) {
	m._Patient_weight = &f
	m.add_Patient_weight = nil
}

// PatientWeight returns the Patient_weight value in the mutation.
func (m *PatientMutation) PatientWeight() (r float64, exists bool) {
	v := m._Patient_weight
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientWeight returns the old Patient_weight value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientWeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientWeight: %w", err)
	}
	return oldValue.PatientWeight, nil
}

// AddPatientWeight adds f to Patient_weight.
func (m *PatientMutation) AddPatientWeight(f float64) {
	if m.add_Patient_weight != nil {
		*m.add_Patient_weight += f
	} else {
		m.add_Patient_weight = &f
	}
}

// AddedPatientWeight returns the value that was added to the Patient_weight field in this mutation.
func (m *PatientMutation) AddedPatientWeight() (r float64, exists bool) {
	v := m.add_Patient_weight
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientWeight reset all changes of the "Patient_weight" field.
func (m *PatientMutation) ResetPatientWeight() {
	m._Patient_weight = nil
	m.add_Patient_weight = nil
}

// SetPatientHeight sets the Patient_height field.
func (m *PatientMutation) SetPatientHeight(f float64) {
	m._Patient_height = &f
	m.add_Patient_height = nil
}

// PatientHeight returns the Patient_height value in the mutation.
func (m *PatientMutation) PatientHeight() (r float64, exists bool) {
	v := m._Patient_height
	if v == nil {
		return
	}
	return *v, true
}

// OldPatientHeight returns the old Patient_height value of the Patient.
// If the Patient object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientMutation) OldPatientHeight(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPatientHeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPatientHeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPatientHeight: %w", err)
	}
	return oldValue.PatientHeight, nil
}

// AddPatientHeight adds f to Patient_height.
func (m *PatientMutation) AddPatientHeight(f float64) {
	if m.add_Patient_height != nil {
		*m.add_Patient_height += f
	} else {
		m.add_Patient_height = &f
	}
}

// AddedPatientHeight returns the value that was added to the Patient_height field in this mutation.
func (m *PatientMutation) AddedPatientHeight() (r float64, exists bool) {
	v := m.add_Patient_height
	if v == nil {
		return
	}
	return *v, true
}

// ResetPatientHeight reset all changes of the "Patient_height" field.
func (m *PatientMutation) ResetPatientHeight() {
	m._Patient_height = nil
	m.add_Patient_height = nil
}

// SetGenderID sets the gender edge to Gender by id.
func (m *PatientMutation) SetGenderID(id int) {
	m.gender = &id
}

// ClearGender clears the gender edge to Gender.
func (m *PatientMutation) ClearGender() {
	m.clearedgender = true
}

// GenderCleared returns if the edge gender was cleared.
func (m *PatientMutation) GenderCleared() bool {
	return m.clearedgender
}

// GenderID returns the gender id in the mutation.
func (m *PatientMutation) GenderID() (id int, exists bool) {
	if m.gender != nil {
		return *m.gender, true
	}
	return
}

// GenderIDs returns the gender ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// GenderID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) GenderIDs() (ids []int) {
	if id := m.gender; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGender reset all changes of the "gender" edge.
func (m *PatientMutation) ResetGender() {
	m.gender = nil
	m.clearedgender = false
}

// SetPrefixID sets the prefix edge to Prefix by id.
func (m *PatientMutation) SetPrefixID(id int) {
	m.prefix = &id
}

// ClearPrefix clears the prefix edge to Prefix.
func (m *PatientMutation) ClearPrefix() {
	m.clearedprefix = true
}

// PrefixCleared returns if the edge prefix was cleared.
func (m *PatientMutation) PrefixCleared() bool {
	return m.clearedprefix
}

// PrefixID returns the prefix id in the mutation.
func (m *PatientMutation) PrefixID() (id int, exists bool) {
	if m.prefix != nil {
		return *m.prefix, true
	}
	return
}

// PrefixIDs returns the prefix ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PrefixID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) PrefixIDs() (ids []int) {
	if id := m.prefix; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPrefix reset all changes of the "prefix" edge.
func (m *PatientMutation) ResetPrefix() {
	m.prefix = nil
	m.clearedprefix = false
}

// SetBloodtypeID sets the bloodtype edge to Bloodtype by id.
func (m *PatientMutation) SetBloodtypeID(id int) {
	m.bloodtype = &id
}

// ClearBloodtype clears the bloodtype edge to Bloodtype.
func (m *PatientMutation) ClearBloodtype() {
	m.clearedbloodtype = true
}

// BloodtypeCleared returns if the edge bloodtype was cleared.
func (m *PatientMutation) BloodtypeCleared() bool {
	return m.clearedbloodtype
}

// BloodtypeID returns the bloodtype id in the mutation.
func (m *PatientMutation) BloodtypeID() (id int, exists bool) {
	if m.bloodtype != nil {
		return *m.bloodtype, true
	}
	return
}

// BloodtypeIDs returns the bloodtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// BloodtypeID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) BloodtypeIDs() (ids []int) {
	if id := m.bloodtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetBloodtype reset all changes of the "bloodtype" edge.
func (m *PatientMutation) ResetBloodtype() {
	m.bloodtype = nil
	m.clearedbloodtype = false
}

// SetFrompatientID sets the frompatient edge to Rent by id.
func (m *PatientMutation) SetFrompatientID(id int) {
	m.frompatient = &id
}

// ClearFrompatient clears the frompatient edge to Rent.
func (m *PatientMutation) ClearFrompatient() {
	m.clearedfrompatient = true
}

// FrompatientCleared returns if the edge frompatient was cleared.
func (m *PatientMutation) FrompatientCleared() bool {
	return m.clearedfrompatient
}

// FrompatientID returns the frompatient id in the mutation.
func (m *PatientMutation) FrompatientID() (id int, exists bool) {
	if m.frompatient != nil {
		return *m.frompatient, true
	}
	return
}

// FrompatientIDs returns the frompatient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// FrompatientID instead. It exists only for internal usage by the builders.
func (m *PatientMutation) FrompatientIDs() (ids []int) {
	if id := m.frompatient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFrompatient reset all changes of the "frompatient" edge.
func (m *PatientMutation) ResetFrompatient() {
	m.frompatient = nil
	m.clearedfrompatient = false
}

// AddPatientCoveredPersonIDs adds the Patient_CoveredPerson edge to CoveredPerson by ids.
func (m *PatientMutation) AddPatientCoveredPersonIDs(ids ...int) {
	if m._Patient_CoveredPerson == nil {
		m._Patient_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._Patient_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovePatientCoveredPersonIDs removes the Patient_CoveredPerson edge to CoveredPerson by ids.
func (m *PatientMutation) RemovePatientCoveredPersonIDs(ids ...int) {
	if m.removed_Patient_CoveredPerson == nil {
		m.removed_Patient_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Patient_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedPatientCoveredPerson returns the removed ids of Patient_CoveredPerson.
func (m *PatientMutation) RemovedPatientCoveredPersonIDs() (ids []int) {
	for id := range m.removed_Patient_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// PatientCoveredPersonIDs returns the Patient_CoveredPerson ids in the mutation.
func (m *PatientMutation) PatientCoveredPersonIDs() (ids []int) {
	for id := range m._Patient_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetPatientCoveredPerson reset all changes of the "Patient_CoveredPerson" edge.
func (m *PatientMutation) ResetPatientCoveredPerson() {
	m._Patient_CoveredPerson = nil
	m.removed_Patient_CoveredPerson = nil
}

// AddPatientDiagnoseIDs adds the patient_diagnose edge to Diagnose by ids.
func (m *PatientMutation) AddPatientDiagnoseIDs(ids ...int) {
	if m.patient_diagnose == nil {
		m.patient_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_diagnose[ids[i]] = struct{}{}
	}
}

// RemovePatientDiagnoseIDs removes the patient_diagnose edge to Diagnose by ids.
func (m *PatientMutation) RemovePatientDiagnoseIDs(ids ...int) {
	if m.removedpatient_diagnose == nil {
		m.removedpatient_diagnose = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatient_diagnose[ids[i]] = struct{}{}
	}
}

// RemovedPatientDiagnose returns the removed ids of patient_diagnose.
func (m *PatientMutation) RemovedPatientDiagnoseIDs() (ids []int) {
	for id := range m.removedpatient_diagnose {
		ids = append(ids, id)
	}
	return
}

// PatientDiagnoseIDs returns the patient_diagnose ids in the mutation.
func (m *PatientMutation) PatientDiagnoseIDs() (ids []int) {
	for id := range m.patient_diagnose {
		ids = append(ids, id)
	}
	return
}

// ResetPatientDiagnose reset all changes of the "patient_diagnose" edge.
func (m *PatientMutation) ResetPatientDiagnose() {
	m.patient_diagnose = nil
	m.removedpatient_diagnose = nil
}

// AddPatientPrescriptionIDs adds the patient_prescription edge to Prescription by ids.
func (m *PatientMutation) AddPatientPrescriptionIDs(ids ...int) {
	if m.patient_prescription == nil {
		m.patient_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.patient_prescription[ids[i]] = struct{}{}
	}
}

// RemovePatientPrescriptionIDs removes the patient_prescription edge to Prescription by ids.
func (m *PatientMutation) RemovePatientPrescriptionIDs(ids ...int) {
	if m.removedpatient_prescription == nil {
		m.removedpatient_prescription = make(map[int]struct{})
	}
	for i := range ids {
		m.removedpatient_prescription[ids[i]] = struct{}{}
	}
}

// RemovedPatientPrescription returns the removed ids of patient_prescription.
func (m *PatientMutation) RemovedPatientPrescriptionIDs() (ids []int) {
	for id := range m.removedpatient_prescription {
		ids = append(ids, id)
	}
	return
}

// PatientPrescriptionIDs returns the patient_prescription ids in the mutation.
func (m *PatientMutation) PatientPrescriptionIDs() (ids []int) {
	for id := range m.patient_prescription {
		ids = append(ids, id)
	}
	return
}

// ResetPatientPrescription reset all changes of the "patient_prescription" edge.
func (m *PatientMutation) ResetPatientPrescription() {
	m.patient_prescription = nil
	m.removedpatient_prescription = nil
}

// Op returns the operation name.
func (m *PatientMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patient).
func (m *PatientMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m._Patient_name != nil {
		fields = append(fields, patient.FieldPatientName)
	}
	if m._Patient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	if m._Patient_weight != nil {
		fields = append(fields, patient.FieldPatientWeight)
	}
	if m._Patient_height != nil {
		fields = append(fields, patient.FieldPatientHeight)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientName:
		return m.PatientName()
	case patient.FieldPatientAge:
		return m.PatientAge()
	case patient.FieldPatientWeight:
		return m.PatientWeight()
	case patient.FieldPatientHeight:
		return m.PatientHeight()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patient.FieldPatientName:
		return m.OldPatientName(ctx)
	case patient.FieldPatientAge:
		return m.OldPatientAge(ctx)
	case patient.FieldPatientWeight:
		return m.OldPatientWeight(ctx)
	case patient.FieldPatientHeight:
		return m.OldPatientHeight(ctx)
	}
	return nil, fmt.Errorf("unknown Patient field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientName(v)
		return nil
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientAge(v)
		return nil
	case patient.FieldPatientWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientWeight(v)
		return nil
	case patient.FieldPatientHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPatientHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientMutation) AddedFields() []string {
	var fields []string
	if m.add_Patient_age != nil {
		fields = append(fields, patient.FieldPatientAge)
	}
	if m.add_Patient_weight != nil {
		fields = append(fields, patient.FieldPatientWeight)
	}
	if m.add_Patient_height != nil {
		fields = append(fields, patient.FieldPatientHeight)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case patient.FieldPatientAge:
		return m.AddedPatientAge()
	case patient.FieldPatientWeight:
		return m.AddedPatientWeight()
	case patient.FieldPatientHeight:
		return m.AddedPatientHeight()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientMutation) AddField(name string, value ent.Value) error {
	switch name {
	case patient.FieldPatientAge:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientAge(v)
		return nil
	case patient.FieldPatientWeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientWeight(v)
		return nil
	case patient.FieldPatientHeight:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPatientHeight(v)
		return nil
	}
	return fmt.Errorf("unknown Patient numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patient nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientMutation) ResetField(name string) error {
	switch name {
	case patient.FieldPatientName:
		m.ResetPatientName()
		return nil
	case patient.FieldPatientAge:
		m.ResetPatientAge()
		return nil
	case patient.FieldPatientWeight:
		m.ResetPatientWeight()
		return nil
	case patient.FieldPatientHeight:
		m.ResetPatientHeight()
		return nil
	}
	return fmt.Errorf("unknown Patient field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.gender != nil {
		edges = append(edges, patient.EdgeGender)
	}
	if m.prefix != nil {
		edges = append(edges, patient.EdgePrefix)
	}
	if m.bloodtype != nil {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.frompatient != nil {
		edges = append(edges, patient.EdgeFrompatient)
	}
	if m._Patient_CoveredPerson != nil {
		edges = append(edges, patient.EdgePatientCoveredPerson)
	}
	if m.patient_diagnose != nil {
		edges = append(edges, patient.EdgePatientDiagnose)
	}
	if m.patient_prescription != nil {
		edges = append(edges, patient.EdgePatientPrescription)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgeGender:
		if id := m.gender; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePrefix:
		if id := m.prefix; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeBloodtype:
		if id := m.bloodtype; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgeFrompatient:
		if id := m.frompatient; id != nil {
			return []ent.Value{*id}
		}
	case patient.EdgePatientCoveredPerson:
		ids := make([]ent.Value, 0, len(m._Patient_CoveredPerson))
		for id := range m._Patient_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientDiagnose:
		ids := make([]ent.Value, 0, len(m.patient_diagnose))
		for id := range m.patient_diagnose {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientPrescription:
		ids := make([]ent.Value, 0, len(m.patient_prescription))
		for id := range m.patient_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removed_Patient_CoveredPerson != nil {
		edges = append(edges, patient.EdgePatientCoveredPerson)
	}
	if m.removedpatient_diagnose != nil {
		edges = append(edges, patient.EdgePatientDiagnose)
	}
	if m.removedpatient_prescription != nil {
		edges = append(edges, patient.EdgePatientPrescription)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patient.EdgePatientCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_Patient_CoveredPerson))
		for id := range m.removed_Patient_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientDiagnose:
		ids := make([]ent.Value, 0, len(m.removedpatient_diagnose))
		for id := range m.removedpatient_diagnose {
			ids = append(ids, id)
		}
		return ids
	case patient.EdgePatientPrescription:
		ids := make([]ent.Value, 0, len(m.removedpatient_prescription))
		for id := range m.removedpatient_prescription {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedgender {
		edges = append(edges, patient.EdgeGender)
	}
	if m.clearedprefix {
		edges = append(edges, patient.EdgePrefix)
	}
	if m.clearedbloodtype {
		edges = append(edges, patient.EdgeBloodtype)
	}
	if m.clearedfrompatient {
		edges = append(edges, patient.EdgeFrompatient)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientMutation) EdgeCleared(name string) bool {
	switch name {
	case patient.EdgeGender:
		return m.clearedgender
	case patient.EdgePrefix:
		return m.clearedprefix
	case patient.EdgeBloodtype:
		return m.clearedbloodtype
	case patient.EdgeFrompatient:
		return m.clearedfrompatient
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientMutation) ClearEdge(name string) error {
	switch name {
	case patient.EdgeGender:
		m.ClearGender()
		return nil
	case patient.EdgePrefix:
		m.ClearPrefix()
		return nil
	case patient.EdgeBloodtype:
		m.ClearBloodtype()
		return nil
	case patient.EdgeFrompatient:
		m.ClearFrompatient()
		return nil
	}
	return fmt.Errorf("unknown Patient unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientMutation) ResetEdge(name string) error {
	switch name {
	case patient.EdgeGender:
		m.ResetGender()
		return nil
	case patient.EdgePrefix:
		m.ResetPrefix()
		return nil
	case patient.EdgeBloodtype:
		m.ResetBloodtype()
		return nil
	case patient.EdgeFrompatient:
		m.ResetFrompatient()
		return nil
	case patient.EdgePatientCoveredPerson:
		m.ResetPatientCoveredPerson()
		return nil
	case patient.EdgePatientDiagnose:
		m.ResetPatientDiagnose()
		return nil
	case patient.EdgePatientPrescription:
		m.ResetPatientPrescription()
		return nil
	}
	return fmt.Errorf("unknown Patient edge %s", name)
}

// PrefixMutation represents an operation that mutate the Prefixes
// nodes in the graph.
type PrefixMutation struct {
	config
	op                Op
	typ               string
	id                *int
	_Pname            *string
	clearedFields     map[string]struct{}
	fromprefix        map[int]struct{}
	removedfromprefix map[int]struct{}
	done              bool
	oldValue          func(context.Context) (*Prefix, error)
}

var _ ent.Mutation = (*PrefixMutation)(nil)

// prefixOption allows to manage the mutation configuration using functional options.
type prefixOption func(*PrefixMutation)

// newPrefixMutation creates new mutation for $n.Name.
func newPrefixMutation(c config, op Op, opts ...prefixOption) *PrefixMutation {
	m := &PrefixMutation{
		config:        c,
		op:            op,
		typ:           TypePrefix,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrefixID sets the id field of the mutation.
func withPrefixID(id int) prefixOption {
	return func(m *PrefixMutation) {
		var (
			err   error
			once  sync.Once
			value *Prefix
		)
		m.oldValue = func(ctx context.Context) (*Prefix, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prefix.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrefix sets the old Prefix of the mutation.
func withPrefix(node *Prefix) prefixOption {
	return func(m *PrefixMutation) {
		m.oldValue = func(context.Context) (*Prefix, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrefixMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrefixMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrefixMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPname sets the Pname field.
func (m *PrefixMutation) SetPname(s string) {
	m._Pname = &s
}

// Pname returns the Pname value in the mutation.
func (m *PrefixMutation) Pname() (r string, exists bool) {
	v := m._Pname
	if v == nil {
		return
	}
	return *v, true
}

// OldPname returns the old Pname value of the Prefix.
// If the Prefix object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrefixMutation) OldPname(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPname is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPname requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPname: %w", err)
	}
	return oldValue.Pname, nil
}

// ResetPname reset all changes of the "Pname" field.
func (m *PrefixMutation) ResetPname() {
	m._Pname = nil
}

// AddFromprefixIDs adds the fromprefix edge to Patient by ids.
func (m *PrefixMutation) AddFromprefixIDs(ids ...int) {
	if m.fromprefix == nil {
		m.fromprefix = make(map[int]struct{})
	}
	for i := range ids {
		m.fromprefix[ids[i]] = struct{}{}
	}
}

// RemoveFromprefixIDs removes the fromprefix edge to Patient by ids.
func (m *PrefixMutation) RemoveFromprefixIDs(ids ...int) {
	if m.removedfromprefix == nil {
		m.removedfromprefix = make(map[int]struct{})
	}
	for i := range ids {
		m.removedfromprefix[ids[i]] = struct{}{}
	}
}

// RemovedFromprefix returns the removed ids of fromprefix.
func (m *PrefixMutation) RemovedFromprefixIDs() (ids []int) {
	for id := range m.removedfromprefix {
		ids = append(ids, id)
	}
	return
}

// FromprefixIDs returns the fromprefix ids in the mutation.
func (m *PrefixMutation) FromprefixIDs() (ids []int) {
	for id := range m.fromprefix {
		ids = append(ids, id)
	}
	return
}

// ResetFromprefix reset all changes of the "fromprefix" edge.
func (m *PrefixMutation) ResetFromprefix() {
	m.fromprefix = nil
	m.removedfromprefix = nil
}

// Op returns the operation name.
func (m *PrefixMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prefix).
func (m *PrefixMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrefixMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Pname != nil {
		fields = append(fields, prefix.FieldPname)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrefixMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prefix.FieldPname:
		return m.Pname()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrefixMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prefix.FieldPname:
		return m.OldPname(ctx)
	}
	return nil, fmt.Errorf("unknown Prefix field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prefix.FieldPname:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPname(v)
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrefixMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrefixMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrefixMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrefixMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrefixMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrefixMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prefix nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrefixMutation) ResetField(name string) error {
	switch name {
	case prefix.FieldPname:
		m.ResetPname()
		return nil
	}
	return fmt.Errorf("unknown Prefix field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrefixMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.fromprefix != nil {
		edges = append(edges, prefix.EdgeFromprefix)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrefixMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgeFromprefix:
		ids := make([]ent.Value, 0, len(m.fromprefix))
		for id := range m.fromprefix {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrefixMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedfromprefix != nil {
		edges = append(edges, prefix.EdgeFromprefix)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrefixMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case prefix.EdgeFromprefix:
		ids := make([]ent.Value, 0, len(m.removedfromprefix))
		for id := range m.removedfromprefix {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrefixMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrefixMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrefixMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Prefix unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrefixMutation) ResetEdge(name string) error {
	switch name {
	case prefix.EdgeFromprefix:
		m.ResetFromprefix()
		return nil
	}
	return fmt.Errorf("unknown Prefix edge %s", name)
}

// PrescriptionMutation represents an operation that mutate the Prescriptions
// nodes in the graph.
type PrescriptionMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	_Prescrip_Note     *string
	_Prescrip_DateTime *time.Time
	clearedFields      map[string]struct{}
	doctor             *int
	cleareddoctor      bool
	patient            *int
	clearedpatient     bool
	nurse              *int
	clearednurse       bool
	drug               *int
	cleareddrug        bool
	done               bool
	oldValue           func(context.Context) (*Prescription, error)
}

var _ ent.Mutation = (*PrescriptionMutation)(nil)

// prescriptionOption allows to manage the mutation configuration using functional options.
type prescriptionOption func(*PrescriptionMutation)

// newPrescriptionMutation creates new mutation for $n.Name.
func newPrescriptionMutation(c config, op Op, opts ...prescriptionOption) *PrescriptionMutation {
	m := &PrescriptionMutation{
		config:        c,
		op:            op,
		typ:           TypePrescription,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPrescriptionID sets the id field of the mutation.
func withPrescriptionID(id int) prescriptionOption {
	return func(m *PrescriptionMutation) {
		var (
			err   error
			once  sync.Once
			value *Prescription
		)
		m.oldValue = func(ctx context.Context) (*Prescription, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Prescription.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPrescription sets the old Prescription of the mutation.
func withPrescription(node *Prescription) prescriptionOption {
	return func(m *PrescriptionMutation) {
		m.oldValue = func(context.Context) (*Prescription, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PrescriptionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PrescriptionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PrescriptionMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetPrescripNote sets the Prescrip_Note field.
func (m *PrescriptionMutation) SetPrescripNote(s string) {
	m._Prescrip_Note = &s
}

// PrescripNote returns the Prescrip_Note value in the mutation.
func (m *PrescriptionMutation) PrescripNote() (r string, exists bool) {
	v := m._Prescrip_Note
	if v == nil {
		return
	}
	return *v, true
}

// OldPrescripNote returns the old Prescrip_Note value of the Prescription.
// If the Prescription object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrescriptionMutation) OldPrescripNote(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrescripNote is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrescripNote requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrescripNote: %w", err)
	}
	return oldValue.PrescripNote, nil
}

// ResetPrescripNote reset all changes of the "Prescrip_Note" field.
func (m *PrescriptionMutation) ResetPrescripNote() {
	m._Prescrip_Note = nil
}

// SetPrescripDateTime sets the Prescrip_DateTime field.
func (m *PrescriptionMutation) SetPrescripDateTime(t time.Time) {
	m._Prescrip_DateTime = &t
}

// PrescripDateTime returns the Prescrip_DateTime value in the mutation.
func (m *PrescriptionMutation) PrescripDateTime() (r time.Time, exists bool) {
	v := m._Prescrip_DateTime
	if v == nil {
		return
	}
	return *v, true
}

// OldPrescripDateTime returns the old Prescrip_DateTime value of the Prescription.
// If the Prescription object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PrescriptionMutation) OldPrescripDateTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPrescripDateTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPrescripDateTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrescripDateTime: %w", err)
	}
	return oldValue.PrescripDateTime, nil
}

// ResetPrescripDateTime reset all changes of the "Prescrip_DateTime" field.
func (m *PrescriptionMutation) ResetPrescripDateTime() {
	m._Prescrip_DateTime = nil
}

// SetDoctorID sets the doctor edge to Doctor by id.
func (m *PrescriptionMutation) SetDoctorID(id int) {
	m.doctor = &id
}

// ClearDoctor clears the doctor edge to Doctor.
func (m *PrescriptionMutation) ClearDoctor() {
	m.cleareddoctor = true
}

// DoctorCleared returns if the edge doctor was cleared.
func (m *PrescriptionMutation) DoctorCleared() bool {
	return m.cleareddoctor
}

// DoctorID returns the doctor id in the mutation.
func (m *PrescriptionMutation) DoctorID() (id int, exists bool) {
	if m.doctor != nil {
		return *m.doctor, true
	}
	return
}

// DoctorIDs returns the doctor ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DoctorID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) DoctorIDs() (ids []int) {
	if id := m.doctor; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDoctor reset all changes of the "doctor" edge.
func (m *PrescriptionMutation) ResetDoctor() {
	m.doctor = nil
	m.cleareddoctor = false
}

// SetPatientID sets the patient edge to Patient by id.
func (m *PrescriptionMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to Patient.
func (m *PrescriptionMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *PrescriptionMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *PrescriptionMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *PrescriptionMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetNurseID sets the nurse edge to Nurse by id.
func (m *PrescriptionMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the nurse edge to Nurse.
func (m *PrescriptionMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the edge nurse was cleared.
func (m *PrescriptionMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the nurse id in the mutation.
func (m *PrescriptionMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "nurse" edge.
func (m *PrescriptionMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// SetDrugID sets the drug edge to Drug by id.
func (m *PrescriptionMutation) SetDrugID(id int) {
	m.drug = &id
}

// ClearDrug clears the drug edge to Drug.
func (m *PrescriptionMutation) ClearDrug() {
	m.cleareddrug = true
}

// DrugCleared returns if the edge drug was cleared.
func (m *PrescriptionMutation) DrugCleared() bool {
	return m.cleareddrug
}

// DrugID returns the drug id in the mutation.
func (m *PrescriptionMutation) DrugID() (id int, exists bool) {
	if m.drug != nil {
		return *m.drug, true
	}
	return
}

// DrugIDs returns the drug ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DrugID instead. It exists only for internal usage by the builders.
func (m *PrescriptionMutation) DrugIDs() (ids []int) {
	if id := m.drug; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDrug reset all changes of the "drug" edge.
func (m *PrescriptionMutation) ResetDrug() {
	m.drug = nil
	m.cleareddrug = false
}

// Op returns the operation name.
func (m *PrescriptionMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Prescription).
func (m *PrescriptionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PrescriptionMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m._Prescrip_Note != nil {
		fields = append(fields, prescription.FieldPrescripNote)
	}
	if m._Prescrip_DateTime != nil {
		fields = append(fields, prescription.FieldPrescripDateTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PrescriptionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case prescription.FieldPrescripNote:
		return m.PrescripNote()
	case prescription.FieldPrescripDateTime:
		return m.PrescripDateTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PrescriptionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case prescription.FieldPrescripNote:
		return m.OldPrescripNote(ctx)
	case prescription.FieldPrescripDateTime:
		return m.OldPrescripDateTime(ctx)
	}
	return nil, fmt.Errorf("unknown Prescription field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrescriptionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case prescription.FieldPrescripNote:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrescripNote(v)
		return nil
	case prescription.FieldPrescripDateTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrescripDateTime(v)
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PrescriptionMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PrescriptionMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PrescriptionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Prescription numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PrescriptionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PrescriptionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PrescriptionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Prescription nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PrescriptionMutation) ResetField(name string) error {
	switch name {
	case prescription.FieldPrescripNote:
		m.ResetPrescripNote()
		return nil
	case prescription.FieldPrescripDateTime:
		m.ResetPrescripDateTime()
		return nil
	}
	return fmt.Errorf("unknown Prescription field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PrescriptionMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.doctor != nil {
		edges = append(edges, prescription.EdgeDoctor)
	}
	if m.patient != nil {
		edges = append(edges, prescription.EdgePatient)
	}
	if m.nurse != nil {
		edges = append(edges, prescription.EdgeNurse)
	}
	if m.drug != nil {
		edges = append(edges, prescription.EdgeDrug)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PrescriptionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case prescription.EdgeDoctor:
		if id := m.doctor; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	case prescription.EdgeDrug:
		if id := m.drug; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PrescriptionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PrescriptionMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PrescriptionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareddoctor {
		edges = append(edges, prescription.EdgeDoctor)
	}
	if m.clearedpatient {
		edges = append(edges, prescription.EdgePatient)
	}
	if m.clearednurse {
		edges = append(edges, prescription.EdgeNurse)
	}
	if m.cleareddrug {
		edges = append(edges, prescription.EdgeDrug)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PrescriptionMutation) EdgeCleared(name string) bool {
	switch name {
	case prescription.EdgeDoctor:
		return m.cleareddoctor
	case prescription.EdgePatient:
		return m.clearedpatient
	case prescription.EdgeNurse:
		return m.clearednurse
	case prescription.EdgeDrug:
		return m.cleareddrug
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PrescriptionMutation) ClearEdge(name string) error {
	switch name {
	case prescription.EdgeDoctor:
		m.ClearDoctor()
		return nil
	case prescription.EdgePatient:
		m.ClearPatient()
		return nil
	case prescription.EdgeNurse:
		m.ClearNurse()
		return nil
	case prescription.EdgeDrug:
		m.ClearDrug()
		return nil
	}
	return fmt.Errorf("unknown Prescription unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PrescriptionMutation) ResetEdge(name string) error {
	switch name {
	case prescription.EdgeDoctor:
		m.ResetDoctor()
		return nil
	case prescription.EdgePatient:
		m.ResetPatient()
		return nil
	case prescription.EdgeNurse:
		m.ResetNurse()
		return nil
	case prescription.EdgeDrug:
		m.ResetDrug()
		return nil
	}
	return fmt.Errorf("unknown Prescription edge %s", name)
}

// RentMutation represents an operation that mutate the Rents
// nodes in the graph.
type RentMutation struct {
	config
	op             Op
	typ            string
	id             *int
	added_time     *time.Time
	clearedFields  map[string]struct{}
	room           *int
	clearedroom    bool
	patient        *int
	clearedpatient bool
	nurse          *int
	clearednurse   bool
	done           bool
	oldValue       func(context.Context) (*Rent, error)
}

var _ ent.Mutation = (*RentMutation)(nil)

// rentOption allows to manage the mutation configuration using functional options.
type rentOption func(*RentMutation)

// newRentMutation creates new mutation for $n.Name.
func newRentMutation(c config, op Op, opts ...rentOption) *RentMutation {
	m := &RentMutation{
		config:        c,
		op:            op,
		typ:           TypeRent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRentID sets the id field of the mutation.
func withRentID(id int) rentOption {
	return func(m *RentMutation) {
		var (
			err   error
			once  sync.Once
			value *Rent
		)
		m.oldValue = func(ctx context.Context) (*Rent, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Rent.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRent sets the old Rent of the mutation.
func withRent(node *Rent) rentOption {
	return func(m *RentMutation) {
		m.oldValue = func(context.Context) (*Rent, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAddedTime sets the added_time field.
func (m *RentMutation) SetAddedTime(t time.Time) {
	m.added_time = &t
}

// AddedTime returns the added_time value in the mutation.
func (m *RentMutation) AddedTime() (r time.Time, exists bool) {
	v := m.added_time
	if v == nil {
		return
	}
	return *v, true
}

// OldAddedTime returns the old added_time value of the Rent.
// If the Rent object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RentMutation) OldAddedTime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddedTime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddedTime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddedTime: %w", err)
	}
	return oldValue.AddedTime, nil
}

// ResetAddedTime reset all changes of the "added_time" field.
func (m *RentMutation) ResetAddedTime() {
	m.added_time = nil
}

// SetRoomID sets the room edge to Room by id.
func (m *RentMutation) SetRoomID(id int) {
	m.room = &id
}

// ClearRoom clears the room edge to Room.
func (m *RentMutation) ClearRoom() {
	m.clearedroom = true
}

// RoomCleared returns if the edge room was cleared.
func (m *RentMutation) RoomCleared() bool {
	return m.clearedroom
}

// RoomID returns the room id in the mutation.
func (m *RentMutation) RoomID() (id int, exists bool) {
	if m.room != nil {
		return *m.room, true
	}
	return
}

// RoomIDs returns the room ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomID instead. It exists only for internal usage by the builders.
func (m *RentMutation) RoomIDs() (ids []int) {
	if id := m.room; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoom reset all changes of the "room" edge.
func (m *RentMutation) ResetRoom() {
	m.room = nil
	m.clearedroom = false
}

// SetPatientID sets the patient edge to Patient by id.
func (m *RentMutation) SetPatientID(id int) {
	m.patient = &id
}

// ClearPatient clears the patient edge to Patient.
func (m *RentMutation) ClearPatient() {
	m.clearedpatient = true
}

// PatientCleared returns if the edge patient was cleared.
func (m *RentMutation) PatientCleared() bool {
	return m.clearedpatient
}

// PatientID returns the patient id in the mutation.
func (m *RentMutation) PatientID() (id int, exists bool) {
	if m.patient != nil {
		return *m.patient, true
	}
	return
}

// PatientIDs returns the patient ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientID instead. It exists only for internal usage by the builders.
func (m *RentMutation) PatientIDs() (ids []int) {
	if id := m.patient; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatient reset all changes of the "patient" edge.
func (m *RentMutation) ResetPatient() {
	m.patient = nil
	m.clearedpatient = false
}

// SetNurseID sets the nurse edge to Nurse by id.
func (m *RentMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the nurse edge to Nurse.
func (m *RentMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the edge nurse was cleared.
func (m *RentMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the nurse id in the mutation.
func (m *RentMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *RentMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "nurse" edge.
func (m *RentMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// Op returns the operation name.
func (m *RentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Rent).
func (m *RentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.added_time != nil {
		fields = append(fields, rent.FieldAddedTime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case rent.FieldAddedTime:
		return m.AddedTime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case rent.FieldAddedTime:
		return m.OldAddedTime(ctx)
	}
	return nil, fmt.Errorf("unknown Rent field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case rent.FieldAddedTime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddedTime(v)
		return nil
	}
	return fmt.Errorf("unknown Rent field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Rent numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Rent nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RentMutation) ResetField(name string) error {
	switch name {
	case rent.FieldAddedTime:
		m.ResetAddedTime()
		return nil
	}
	return fmt.Errorf("unknown Rent field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.room != nil {
		edges = append(edges, rent.EdgeRoom)
	}
	if m.patient != nil {
		edges = append(edges, rent.EdgePatient)
	}
	if m.nurse != nil {
		edges = append(edges, rent.EdgeNurse)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case rent.EdgeRoom:
		if id := m.room; id != nil {
			return []ent.Value{*id}
		}
	case rent.EdgePatient:
		if id := m.patient; id != nil {
			return []ent.Value{*id}
		}
	case rent.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedroom {
		edges = append(edges, rent.EdgeRoom)
	}
	if m.clearedpatient {
		edges = append(edges, rent.EdgePatient)
	}
	if m.clearednurse {
		edges = append(edges, rent.EdgeNurse)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RentMutation) EdgeCleared(name string) bool {
	switch name {
	case rent.EdgeRoom:
		return m.clearedroom
	case rent.EdgePatient:
		return m.clearedpatient
	case rent.EdgeNurse:
		return m.clearednurse
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RentMutation) ClearEdge(name string) error {
	switch name {
	case rent.EdgeRoom:
		m.ClearRoom()
		return nil
	case rent.EdgePatient:
		m.ClearPatient()
		return nil
	case rent.EdgeNurse:
		m.ClearNurse()
		return nil
	}
	return fmt.Errorf("unknown Rent unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RentMutation) ResetEdge(name string) error {
	switch name {
	case rent.EdgeRoom:
		m.ResetRoom()
		return nil
	case rent.EdgePatient:
		m.ResetPatient()
		return nil
	case rent.EdgeNurse:
		m.ResetNurse()
		return nil
	}
	return fmt.Errorf("unknown Rent edge %s", name)
}

// RoomMutation represents an operation that mutate the Rooms
// nodes in the graph.
type RoomMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	building        *int
	addbuilding     *int
	floor           *int
	addfloor        *int
	clearedFields   map[string]struct{}
	rents           *int
	clearedrents    bool
	roomtype        *int
	clearedroomtype bool
	done            bool
	oldValue        func(context.Context) (*Room, error)
}

var _ ent.Mutation = (*RoomMutation)(nil)

// roomOption allows to manage the mutation configuration using functional options.
type roomOption func(*RoomMutation)

// newRoomMutation creates new mutation for $n.Name.
func newRoomMutation(c config, op Op, opts ...roomOption) *RoomMutation {
	m := &RoomMutation{
		config:        c,
		op:            op,
		typ:           TypeRoom,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomID sets the id field of the mutation.
func withRoomID(id int) roomOption {
	return func(m *RoomMutation) {
		var (
			err   error
			once  sync.Once
			value *Room
		)
		m.oldValue = func(ctx context.Context) (*Room, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Room.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoom sets the old Room of the mutation.
func withRoom(node *Room) roomOption {
	return func(m *RoomMutation) {
		m.oldValue = func(context.Context) (*Room, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RoomMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RoomMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RoomMutation) ResetName() {
	m.name = nil
}

// SetBuilding sets the building field.
func (m *RoomMutation) SetBuilding(i int) {
	m.building = &i
	m.addbuilding = nil
}

// Building returns the building value in the mutation.
func (m *RoomMutation) Building() (r int, exists bool) {
	v := m.building
	if v == nil {
		return
	}
	return *v, true
}

// OldBuilding returns the old building value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldBuilding(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBuilding is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBuilding requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBuilding: %w", err)
	}
	return oldValue.Building, nil
}

// AddBuilding adds i to building.
func (m *RoomMutation) AddBuilding(i int) {
	if m.addbuilding != nil {
		*m.addbuilding += i
	} else {
		m.addbuilding = &i
	}
}

// AddedBuilding returns the value that was added to the building field in this mutation.
func (m *RoomMutation) AddedBuilding() (r int, exists bool) {
	v := m.addbuilding
	if v == nil {
		return
	}
	return *v, true
}

// ResetBuilding reset all changes of the "building" field.
func (m *RoomMutation) ResetBuilding() {
	m.building = nil
	m.addbuilding = nil
}

// SetFloor sets the floor field.
func (m *RoomMutation) SetFloor(i int) {
	m.floor = &i
	m.addfloor = nil
}

// Floor returns the floor value in the mutation.
func (m *RoomMutation) Floor() (r int, exists bool) {
	v := m.floor
	if v == nil {
		return
	}
	return *v, true
}

// OldFloor returns the old floor value of the Room.
// If the Room object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomMutation) OldFloor(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldFloor is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldFloor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFloor: %w", err)
	}
	return oldValue.Floor, nil
}

// AddFloor adds i to floor.
func (m *RoomMutation) AddFloor(i int) {
	if m.addfloor != nil {
		*m.addfloor += i
	} else {
		m.addfloor = &i
	}
}

// AddedFloor returns the value that was added to the floor field in this mutation.
func (m *RoomMutation) AddedFloor() (r int, exists bool) {
	v := m.addfloor
	if v == nil {
		return
	}
	return *v, true
}

// ResetFloor reset all changes of the "floor" field.
func (m *RoomMutation) ResetFloor() {
	m.floor = nil
	m.addfloor = nil
}

// SetRentsID sets the rents edge to Rent by id.
func (m *RoomMutation) SetRentsID(id int) {
	m.rents = &id
}

// ClearRents clears the rents edge to Rent.
func (m *RoomMutation) ClearRents() {
	m.clearedrents = true
}

// RentsCleared returns if the edge rents was cleared.
func (m *RoomMutation) RentsCleared() bool {
	return m.clearedrents
}

// RentsID returns the rents id in the mutation.
func (m *RoomMutation) RentsID() (id int, exists bool) {
	if m.rents != nil {
		return *m.rents, true
	}
	return
}

// RentsIDs returns the rents ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RentsID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) RentsIDs() (ids []int) {
	if id := m.rents; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRents reset all changes of the "rents" edge.
func (m *RoomMutation) ResetRents() {
	m.rents = nil
	m.clearedrents = false
}

// SetRoomtypeID sets the roomtype edge to Roomtype by id.
func (m *RoomMutation) SetRoomtypeID(id int) {
	m.roomtype = &id
}

// ClearRoomtype clears the roomtype edge to Roomtype.
func (m *RoomMutation) ClearRoomtype() {
	m.clearedroomtype = true
}

// RoomtypeCleared returns if the edge roomtype was cleared.
func (m *RoomMutation) RoomtypeCleared() bool {
	return m.clearedroomtype
}

// RoomtypeID returns the roomtype id in the mutation.
func (m *RoomMutation) RoomtypeID() (id int, exists bool) {
	if m.roomtype != nil {
		return *m.roomtype, true
	}
	return
}

// RoomtypeIDs returns the roomtype ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// RoomtypeID instead. It exists only for internal usage by the builders.
func (m *RoomMutation) RoomtypeIDs() (ids []int) {
	if id := m.roomtype; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetRoomtype reset all changes of the "roomtype" edge.
func (m *RoomMutation) ResetRoomtype() {
	m.roomtype = nil
	m.clearedroomtype = false
}

// Op returns the operation name.
func (m *RoomMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Room).
func (m *RoomMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, room.FieldName)
	}
	if m.building != nil {
		fields = append(fields, room.FieldBuilding)
	}
	if m.floor != nil {
		fields = append(fields, room.FieldFloor)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case room.FieldName:
		return m.Name()
	case room.FieldBuilding:
		return m.Building()
	case room.FieldFloor:
		return m.Floor()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case room.FieldName:
		return m.OldName(ctx)
	case room.FieldBuilding:
		return m.OldBuilding(ctx)
	case room.FieldFloor:
		return m.OldFloor(ctx)
	}
	return nil, fmt.Errorf("unknown Room field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) SetField(name string, value ent.Value) error {
	switch name {
	case room.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case room.FieldBuilding:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBuilding(v)
		return nil
	case room.FieldFloor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFloor(v)
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomMutation) AddedFields() []string {
	var fields []string
	if m.addbuilding != nil {
		fields = append(fields, room.FieldBuilding)
	}
	if m.addfloor != nil {
		fields = append(fields, room.FieldFloor)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case room.FieldBuilding:
		return m.AddedBuilding()
	case room.FieldFloor:
		return m.AddedFloor()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomMutation) AddField(name string, value ent.Value) error {
	switch name {
	case room.FieldBuilding:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBuilding(v)
		return nil
	case room.FieldFloor:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddFloor(v)
		return nil
	}
	return fmt.Errorf("unknown Room numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Room nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomMutation) ResetField(name string) error {
	switch name {
	case room.FieldName:
		m.ResetName()
		return nil
	case room.FieldBuilding:
		m.ResetBuilding()
		return nil
	case room.FieldFloor:
		m.ResetFloor()
		return nil
	}
	return fmt.Errorf("unknown Room field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.rents != nil {
		edges = append(edges, room.EdgeRents)
	}
	if m.roomtype != nil {
		edges = append(edges, room.EdgeRoomtype)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case room.EdgeRents:
		if id := m.rents; id != nil {
			return []ent.Value{*id}
		}
	case room.EdgeRoomtype:
		if id := m.roomtype; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedrents {
		edges = append(edges, room.EdgeRents)
	}
	if m.clearedroomtype {
		edges = append(edges, room.EdgeRoomtype)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomMutation) EdgeCleared(name string) bool {
	switch name {
	case room.EdgeRents:
		return m.clearedrents
	case room.EdgeRoomtype:
		return m.clearedroomtype
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomMutation) ClearEdge(name string) error {
	switch name {
	case room.EdgeRents:
		m.ClearRents()
		return nil
	case room.EdgeRoomtype:
		m.ClearRoomtype()
		return nil
	}
	return fmt.Errorf("unknown Room unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomMutation) ResetEdge(name string) error {
	switch name {
	case room.EdgeRents:
		m.ResetRents()
		return nil
	case room.EdgeRoomtype:
		m.ResetRoomtype()
		return nil
	}
	return fmt.Errorf("unknown Room edge %s", name)
}

// RoomtypeMutation represents an operation that mutate the Roomtypes
// nodes in the graph.
type RoomtypeMutation struct {
	config
	op            Op
	typ           string
	id            *int
	name          *string
	bathroom      *int
	addbathroom   *int
	toilets       *int
	addtoilets    *int
	areasize      *float64
	addareasize   *float64
	etc           *string
	clearedFields map[string]struct{}
	rooms         map[int]struct{}
	removedrooms  map[int]struct{}
	done          bool
	oldValue      func(context.Context) (*Roomtype, error)
}

var _ ent.Mutation = (*RoomtypeMutation)(nil)

// roomtypeOption allows to manage the mutation configuration using functional options.
type roomtypeOption func(*RoomtypeMutation)

// newRoomtypeMutation creates new mutation for $n.Name.
func newRoomtypeMutation(c config, op Op, opts ...roomtypeOption) *RoomtypeMutation {
	m := &RoomtypeMutation{
		config:        c,
		op:            op,
		typ:           TypeRoomtype,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withRoomtypeID sets the id field of the mutation.
func withRoomtypeID(id int) roomtypeOption {
	return func(m *RoomtypeMutation) {
		var (
			err   error
			once  sync.Once
			value *Roomtype
		)
		m.oldValue = func(ctx context.Context) (*Roomtype, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Roomtype.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withRoomtype sets the old Roomtype of the mutation.
func withRoomtype(node *Roomtype) roomtypeOption {
	return func(m *RoomtypeMutation) {
		m.oldValue = func(context.Context) (*Roomtype, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m RoomtypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m RoomtypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *RoomtypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *RoomtypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *RoomtypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *RoomtypeMutation) ResetName() {
	m.name = nil
}

// SetBathroom sets the bathroom field.
func (m *RoomtypeMutation) SetBathroom(i int) {
	m.bathroom = &i
	m.addbathroom = nil
}

// Bathroom returns the bathroom value in the mutation.
func (m *RoomtypeMutation) Bathroom() (r int, exists bool) {
	v := m.bathroom
	if v == nil {
		return
	}
	return *v, true
}

// OldBathroom returns the old bathroom value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldBathroom(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBathroom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBathroom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBathroom: %w", err)
	}
	return oldValue.Bathroom, nil
}

// AddBathroom adds i to bathroom.
func (m *RoomtypeMutation) AddBathroom(i int) {
	if m.addbathroom != nil {
		*m.addbathroom += i
	} else {
		m.addbathroom = &i
	}
}

// AddedBathroom returns the value that was added to the bathroom field in this mutation.
func (m *RoomtypeMutation) AddedBathroom() (r int, exists bool) {
	v := m.addbathroom
	if v == nil {
		return
	}
	return *v, true
}

// ResetBathroom reset all changes of the "bathroom" field.
func (m *RoomtypeMutation) ResetBathroom() {
	m.bathroom = nil
	m.addbathroom = nil
}

// SetToilets sets the toilets field.
func (m *RoomtypeMutation) SetToilets(i int) {
	m.toilets = &i
	m.addtoilets = nil
}

// Toilets returns the toilets value in the mutation.
func (m *RoomtypeMutation) Toilets() (r int, exists bool) {
	v := m.toilets
	if v == nil {
		return
	}
	return *v, true
}

// OldToilets returns the old toilets value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldToilets(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToilets is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToilets requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToilets: %w", err)
	}
	return oldValue.Toilets, nil
}

// AddToilets adds i to toilets.
func (m *RoomtypeMutation) AddToilets(i int) {
	if m.addtoilets != nil {
		*m.addtoilets += i
	} else {
		m.addtoilets = &i
	}
}

// AddedToilets returns the value that was added to the toilets field in this mutation.
func (m *RoomtypeMutation) AddedToilets() (r int, exists bool) {
	v := m.addtoilets
	if v == nil {
		return
	}
	return *v, true
}

// ResetToilets reset all changes of the "toilets" field.
func (m *RoomtypeMutation) ResetToilets() {
	m.toilets = nil
	m.addtoilets = nil
}

// SetAreasize sets the areasize field.
func (m *RoomtypeMutation) SetAreasize(f float64) {
	m.areasize = &f
	m.addareasize = nil
}

// Areasize returns the areasize value in the mutation.
func (m *RoomtypeMutation) Areasize() (r float64, exists bool) {
	v := m.areasize
	if v == nil {
		return
	}
	return *v, true
}

// OldAreasize returns the old areasize value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldAreasize(ctx context.Context) (v float64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAreasize is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAreasize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAreasize: %w", err)
	}
	return oldValue.Areasize, nil
}

// AddAreasize adds f to areasize.
func (m *RoomtypeMutation) AddAreasize(f float64) {
	if m.addareasize != nil {
		*m.addareasize += f
	} else {
		m.addareasize = &f
	}
}

// AddedAreasize returns the value that was added to the areasize field in this mutation.
func (m *RoomtypeMutation) AddedAreasize() (r float64, exists bool) {
	v := m.addareasize
	if v == nil {
		return
	}
	return *v, true
}

// ResetAreasize reset all changes of the "areasize" field.
func (m *RoomtypeMutation) ResetAreasize() {
	m.areasize = nil
	m.addareasize = nil
}

// SetEtc sets the etc field.
func (m *RoomtypeMutation) SetEtc(s string) {
	m.etc = &s
}

// Etc returns the etc value in the mutation.
func (m *RoomtypeMutation) Etc() (r string, exists bool) {
	v := m.etc
	if v == nil {
		return
	}
	return *v, true
}

// OldEtc returns the old etc value of the Roomtype.
// If the Roomtype object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *RoomtypeMutation) OldEtc(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEtc is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEtc requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEtc: %w", err)
	}
	return oldValue.Etc, nil
}

// ResetEtc reset all changes of the "etc" field.
func (m *RoomtypeMutation) ResetEtc() {
	m.etc = nil
}

// AddRoomIDs adds the rooms edge to Room by ids.
func (m *RoomtypeMutation) AddRoomIDs(ids ...int) {
	if m.rooms == nil {
		m.rooms = make(map[int]struct{})
	}
	for i := range ids {
		m.rooms[ids[i]] = struct{}{}
	}
}

// RemoveRoomIDs removes the rooms edge to Room by ids.
func (m *RoomtypeMutation) RemoveRoomIDs(ids ...int) {
	if m.removedrooms == nil {
		m.removedrooms = make(map[int]struct{})
	}
	for i := range ids {
		m.removedrooms[ids[i]] = struct{}{}
	}
}

// RemovedRooms returns the removed ids of rooms.
func (m *RoomtypeMutation) RemovedRoomsIDs() (ids []int) {
	for id := range m.removedrooms {
		ids = append(ids, id)
	}
	return
}

// RoomsIDs returns the rooms ids in the mutation.
func (m *RoomtypeMutation) RoomsIDs() (ids []int) {
	for id := range m.rooms {
		ids = append(ids, id)
	}
	return
}

// ResetRooms reset all changes of the "rooms" edge.
func (m *RoomtypeMutation) ResetRooms() {
	m.rooms = nil
	m.removedrooms = nil
}

// Op returns the operation name.
func (m *RoomtypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Roomtype).
func (m *RoomtypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *RoomtypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, roomtype.FieldName)
	}
	if m.bathroom != nil {
		fields = append(fields, roomtype.FieldBathroom)
	}
	if m.toilets != nil {
		fields = append(fields, roomtype.FieldToilets)
	}
	if m.areasize != nil {
		fields = append(fields, roomtype.FieldAreasize)
	}
	if m.etc != nil {
		fields = append(fields, roomtype.FieldEtc)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *RoomtypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case roomtype.FieldName:
		return m.Name()
	case roomtype.FieldBathroom:
		return m.Bathroom()
	case roomtype.FieldToilets:
		return m.Toilets()
	case roomtype.FieldAreasize:
		return m.Areasize()
	case roomtype.FieldEtc:
		return m.Etc()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *RoomtypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case roomtype.FieldName:
		return m.OldName(ctx)
	case roomtype.FieldBathroom:
		return m.OldBathroom(ctx)
	case roomtype.FieldToilets:
		return m.OldToilets(ctx)
	case roomtype.FieldAreasize:
		return m.OldAreasize(ctx)
	case roomtype.FieldEtc:
		return m.OldEtc(ctx)
	}
	return nil, fmt.Errorf("unknown Roomtype field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomtypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case roomtype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case roomtype.FieldBathroom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBathroom(v)
		return nil
	case roomtype.FieldToilets:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToilets(v)
		return nil
	case roomtype.FieldAreasize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAreasize(v)
		return nil
	case roomtype.FieldEtc:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEtc(v)
		return nil
	}
	return fmt.Errorf("unknown Roomtype field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *RoomtypeMutation) AddedFields() []string {
	var fields []string
	if m.addbathroom != nil {
		fields = append(fields, roomtype.FieldBathroom)
	}
	if m.addtoilets != nil {
		fields = append(fields, roomtype.FieldToilets)
	}
	if m.addareasize != nil {
		fields = append(fields, roomtype.FieldAreasize)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *RoomtypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case roomtype.FieldBathroom:
		return m.AddedBathroom()
	case roomtype.FieldToilets:
		return m.AddedToilets()
	case roomtype.FieldAreasize:
		return m.AddedAreasize()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *RoomtypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	case roomtype.FieldBathroom:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBathroom(v)
		return nil
	case roomtype.FieldToilets:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddToilets(v)
		return nil
	case roomtype.FieldAreasize:
		v, ok := value.(float64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAreasize(v)
		return nil
	}
	return fmt.Errorf("unknown Roomtype numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *RoomtypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *RoomtypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *RoomtypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Roomtype nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *RoomtypeMutation) ResetField(name string) error {
	switch name {
	case roomtype.FieldName:
		m.ResetName()
		return nil
	case roomtype.FieldBathroom:
		m.ResetBathroom()
		return nil
	case roomtype.FieldToilets:
		m.ResetToilets()
		return nil
	case roomtype.FieldAreasize:
		m.ResetAreasize()
		return nil
	case roomtype.FieldEtc:
		m.ResetEtc()
		return nil
	}
	return fmt.Errorf("unknown Roomtype field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *RoomtypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.rooms != nil {
		edges = append(edges, roomtype.EdgeRooms)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *RoomtypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case roomtype.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.rooms))
		for id := range m.rooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *RoomtypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedrooms != nil {
		edges = append(edges, roomtype.EdgeRooms)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *RoomtypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case roomtype.EdgeRooms:
		ids := make([]ent.Value, 0, len(m.removedrooms))
		for id := range m.removedrooms {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *RoomtypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *RoomtypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *RoomtypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Roomtype unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *RoomtypeMutation) ResetEdge(name string) error {
	switch name {
	case roomtype.EdgeRooms:
		m.ResetRooms()
		return nil
	}
	return fmt.Errorf("unknown Roomtype edge %s", name)
}

// SchemeTypeMutation represents an operation that mutate the SchemeTypes
// nodes in the graph.
type SchemeTypeMutation struct {
	config
	op                               Op
	typ                              string
	id                               *int
	_SchemeType_Name                 *string
	clearedFields                    map[string]struct{}
	_SchemeType_CoveredPerson        map[int]struct{}
	removed_SchemeType_CoveredPerson map[int]struct{}
	done                             bool
	oldValue                         func(context.Context) (*SchemeType, error)
}

var _ ent.Mutation = (*SchemeTypeMutation)(nil)

// schemetypeOption allows to manage the mutation configuration using functional options.
type schemetypeOption func(*SchemeTypeMutation)

// newSchemeTypeMutation creates new mutation for $n.Name.
func newSchemeTypeMutation(c config, op Op, opts ...schemetypeOption) *SchemeTypeMutation {
	m := &SchemeTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeSchemeType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSchemeTypeID sets the id field of the mutation.
func withSchemeTypeID(id int) schemetypeOption {
	return func(m *SchemeTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *SchemeType
		)
		m.oldValue = func(ctx context.Context) (*SchemeType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SchemeType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSchemeType sets the old SchemeType of the mutation.
func withSchemeType(node *SchemeType) schemetypeOption {
	return func(m *SchemeTypeMutation) {
		m.oldValue = func(context.Context) (*SchemeType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SchemeTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SchemeTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SchemeTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSchemeTypeName sets the SchemeType_Name field.
func (m *SchemeTypeMutation) SetSchemeTypeName(s string) {
	m._SchemeType_Name = &s
}

// SchemeTypeName returns the SchemeType_Name value in the mutation.
func (m *SchemeTypeMutation) SchemeTypeName() (r string, exists bool) {
	v := m._SchemeType_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldSchemeTypeName returns the old SchemeType_Name value of the SchemeType.
// If the SchemeType object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SchemeTypeMutation) OldSchemeTypeName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSchemeTypeName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSchemeTypeName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSchemeTypeName: %w", err)
	}
	return oldValue.SchemeTypeName, nil
}

// ResetSchemeTypeName reset all changes of the "SchemeType_Name" field.
func (m *SchemeTypeMutation) ResetSchemeTypeName() {
	m._SchemeType_Name = nil
}

// AddSchemeTypeCoveredPersonIDs adds the SchemeType_CoveredPerson edge to CoveredPerson by ids.
func (m *SchemeTypeMutation) AddSchemeTypeCoveredPersonIDs(ids ...int) {
	if m._SchemeType_CoveredPerson == nil {
		m._SchemeType_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m._SchemeType_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemoveSchemeTypeCoveredPersonIDs removes the SchemeType_CoveredPerson edge to CoveredPerson by ids.
func (m *SchemeTypeMutation) RemoveSchemeTypeCoveredPersonIDs(ids ...int) {
	if m.removed_SchemeType_CoveredPerson == nil {
		m.removed_SchemeType_CoveredPerson = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_SchemeType_CoveredPerson[ids[i]] = struct{}{}
	}
}

// RemovedSchemeTypeCoveredPerson returns the removed ids of SchemeType_CoveredPerson.
func (m *SchemeTypeMutation) RemovedSchemeTypeCoveredPersonIDs() (ids []int) {
	for id := range m.removed_SchemeType_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// SchemeTypeCoveredPersonIDs returns the SchemeType_CoveredPerson ids in the mutation.
func (m *SchemeTypeMutation) SchemeTypeCoveredPersonIDs() (ids []int) {
	for id := range m._SchemeType_CoveredPerson {
		ids = append(ids, id)
	}
	return
}

// ResetSchemeTypeCoveredPerson reset all changes of the "SchemeType_CoveredPerson" edge.
func (m *SchemeTypeMutation) ResetSchemeTypeCoveredPerson() {
	m._SchemeType_CoveredPerson = nil
	m.removed_SchemeType_CoveredPerson = nil
}

// Op returns the operation name.
func (m *SchemeTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (SchemeType).
func (m *SchemeTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SchemeTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._SchemeType_Name != nil {
		fields = append(fields, schemetype.FieldSchemeTypeName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SchemeTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case schemetype.FieldSchemeTypeName:
		return m.SchemeTypeName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SchemeTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case schemetype.FieldSchemeTypeName:
		return m.OldSchemeTypeName(ctx)
	}
	return nil, fmt.Errorf("unknown SchemeType field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SchemeTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case schemetype.FieldSchemeTypeName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSchemeTypeName(v)
		return nil
	}
	return fmt.Errorf("unknown SchemeType field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SchemeTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SchemeTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SchemeTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemeType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SchemeTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SchemeTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SchemeTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown SchemeType nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SchemeTypeMutation) ResetField(name string) error {
	switch name {
	case schemetype.FieldSchemeTypeName:
		m.ResetSchemeTypeName()
		return nil
	}
	return fmt.Errorf("unknown SchemeType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SchemeTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._SchemeType_CoveredPerson != nil {
		edges = append(edges, schemetype.EdgeSchemeTypeCoveredPerson)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SchemeTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		ids := make([]ent.Value, 0, len(m._SchemeType_CoveredPerson))
		for id := range m._SchemeType_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SchemeTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_SchemeType_CoveredPerson != nil {
		edges = append(edges, schemetype.EdgeSchemeTypeCoveredPerson)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SchemeTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		ids := make([]ent.Value, 0, len(m.removed_SchemeType_CoveredPerson))
		for id := range m.removed_SchemeType_CoveredPerson {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SchemeTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SchemeTypeMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SchemeTypeMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown SchemeType unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SchemeTypeMutation) ResetEdge(name string) error {
	switch name {
	case schemetype.EdgeSchemeTypeCoveredPerson:
		m.ResetSchemeTypeCoveredPerson()
		return nil
	}
	return fmt.Errorf("unknown SchemeType edge %s", name)
}

// ToolMutation represents an operation that mutate the Tools
// nodes in the graph.
type ToolMutation struct {
	config
	op                           Op
	typ                          string
	id                           *int
	_Tool_Name                   *string
	clearedFields                map[string]struct{}
	_Tool_Operativerecord        map[int]struct{}
	removed_Tool_Operativerecord map[int]struct{}
	done                         bool
	oldValue                     func(context.Context) (*Tool, error)
}

var _ ent.Mutation = (*ToolMutation)(nil)

// toolOption allows to manage the mutation configuration using functional options.
type toolOption func(*ToolMutation)

// newToolMutation creates new mutation for $n.Name.
func newToolMutation(c config, op Op, opts ...toolOption) *ToolMutation {
	m := &ToolMutation{
		config:        c,
		op:            op,
		typ:           TypeTool,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withToolID sets the id field of the mutation.
func withToolID(id int) toolOption {
	return func(m *ToolMutation) {
		var (
			err   error
			once  sync.Once
			value *Tool
		)
		m.oldValue = func(ctx context.Context) (*Tool, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tool.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTool sets the old Tool of the mutation.
func withTool(node *Tool) toolOption {
	return func(m *ToolMutation) {
		m.oldValue = func(context.Context) (*Tool, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ToolMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ToolMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *ToolMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetToolName sets the Tool_Name field.
func (m *ToolMutation) SetToolName(s string) {
	m._Tool_Name = &s
}

// ToolName returns the Tool_Name value in the mutation.
func (m *ToolMutation) ToolName() (r string, exists bool) {
	v := m._Tool_Name
	if v == nil {
		return
	}
	return *v, true
}

// OldToolName returns the old Tool_Name value of the Tool.
// If the Tool object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *ToolMutation) OldToolName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldToolName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldToolName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldToolName: %w", err)
	}
	return oldValue.ToolName, nil
}

// ResetToolName reset all changes of the "Tool_Name" field.
func (m *ToolMutation) ResetToolName() {
	m._Tool_Name = nil
}

// AddToolOperativerecordIDs adds the Tool_Operativerecord edge to Operativerecord by ids.
func (m *ToolMutation) AddToolOperativerecordIDs(ids ...int) {
	if m._Tool_Operativerecord == nil {
		m._Tool_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m._Tool_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemoveToolOperativerecordIDs removes the Tool_Operativerecord edge to Operativerecord by ids.
func (m *ToolMutation) RemoveToolOperativerecordIDs(ids ...int) {
	if m.removed_Tool_Operativerecord == nil {
		m.removed_Tool_Operativerecord = make(map[int]struct{})
	}
	for i := range ids {
		m.removed_Tool_Operativerecord[ids[i]] = struct{}{}
	}
}

// RemovedToolOperativerecord returns the removed ids of Tool_Operativerecord.
func (m *ToolMutation) RemovedToolOperativerecordIDs() (ids []int) {
	for id := range m.removed_Tool_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ToolOperativerecordIDs returns the Tool_Operativerecord ids in the mutation.
func (m *ToolMutation) ToolOperativerecordIDs() (ids []int) {
	for id := range m._Tool_Operativerecord {
		ids = append(ids, id)
	}
	return
}

// ResetToolOperativerecord reset all changes of the "Tool_Operativerecord" edge.
func (m *ToolMutation) ResetToolOperativerecord() {
	m._Tool_Operativerecord = nil
	m.removed_Tool_Operativerecord = nil
}

// Op returns the operation name.
func (m *ToolMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Tool).
func (m *ToolMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *ToolMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Tool_Name != nil {
		fields = append(fields, tool.FieldToolName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *ToolMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tool.FieldToolName:
		return m.ToolName()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *ToolMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tool.FieldToolName:
		return m.OldToolName(ctx)
	}
	return nil, fmt.Errorf("unknown Tool field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ToolMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tool.FieldToolName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetToolName(v)
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *ToolMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *ToolMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *ToolMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *ToolMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *ToolMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *ToolMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Tool nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *ToolMutation) ResetField(name string) error {
	switch name {
	case tool.FieldToolName:
		m.ResetToolName()
		return nil
	}
	return fmt.Errorf("unknown Tool field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *ToolMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m._Tool_Operativerecord != nil {
		edges = append(edges, tool.EdgeToolOperativerecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *ToolMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeToolOperativerecord:
		ids := make([]ent.Value, 0, len(m._Tool_Operativerecord))
		for id := range m._Tool_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *ToolMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removed_Tool_Operativerecord != nil {
		edges = append(edges, tool.EdgeToolOperativerecord)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *ToolMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tool.EdgeToolOperativerecord:
		ids := make([]ent.Value, 0, len(m.removed_Tool_Operativerecord))
		for id := range m.removed_Tool_Operativerecord {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *ToolMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *ToolMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *ToolMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Tool unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *ToolMutation) ResetEdge(name string) error {
	switch name {
	case tool.EdgeToolOperativerecord:
		m.ResetToolOperativerecord()
		return nil
	}
	return fmt.Errorf("unknown Tool edge %s", name)
}
