// Code generated by entc, DO NOT EDIT.

package ent

import (
	"fmt"
	"strings"

	"github.com/facebookincubator/ent/dialect/sql"
	"github.com/sut63/team08/ent/bloodtype"
	"github.com/sut63/team08/ent/gender"
	"github.com/sut63/team08/ent/patient"
	"github.com/sut63/team08/ent/prefix"
	"github.com/sut63/team08/ent/rent"
)

// Patient is the model entity for the Patient schema.
type Patient struct {
	config `json:"-"`
	// ID of the ent.
	ID int `json:"id,omitempty"`
	// PatientName holds the value of the "Patient_name" field.
	PatientName string `json:"Patient_name,omitempty"`
	// PatientAge holds the value of the "Patient_age" field.
	PatientAge int `json:"Patient_age,omitempty"`
	// PatientWeight holds the value of the "Patient_weight" field.
	PatientWeight float64 `json:"Patient_weight,omitempty"`
	// PatientHeight holds the value of the "Patient_height" field.
	PatientHeight float64 `json:"Patient_height,omitempty"`
	// Edges holds the relations/edges for other nodes in the graph.
	// The values are being populated by the PatientQuery when eager-loading is set.
	Edges        PatientEdges `json:"edges"`
	bloodtype_id *int
	gender_id    *int
	prefix_id    *int
}

// PatientEdges holds the relations/edges for other nodes in the graph.
type PatientEdges struct {
	// Gender holds the value of the gender edge.
	Gender *Gender
	// Prefix holds the value of the prefix edge.
	Prefix *Prefix
	// Bloodtype holds the value of the bloodtype edge.
	Bloodtype *Bloodtype
	// Frompatient holds the value of the frompatient edge.
	Frompatient *Rent
	// PatientCoveredPerson holds the value of the Patient_CoveredPerson edge.
	PatientCoveredPerson []*CoveredPerson
	// PatientDiagnose holds the value of the patient_diagnose edge.
	PatientDiagnose []*Diagnose
	// PatientPrescription holds the value of the patient_prescription edge.
	PatientPrescription []*Prescription
	// loadedTypes holds the information for reporting if a
	// type was loaded (or requested) in eager-loading or not.
	loadedTypes [7]bool
}

// GenderOrErr returns the Gender value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PatientEdges) GenderOrErr() (*Gender, error) {
	if e.loadedTypes[0] {
		if e.Gender == nil {
			// The edge gender was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: gender.Label}
		}
		return e.Gender, nil
	}
	return nil, &NotLoadedError{edge: "gender"}
}

// PrefixOrErr returns the Prefix value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PatientEdges) PrefixOrErr() (*Prefix, error) {
	if e.loadedTypes[1] {
		if e.Prefix == nil {
			// The edge prefix was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: prefix.Label}
		}
		return e.Prefix, nil
	}
	return nil, &NotLoadedError{edge: "prefix"}
}

// BloodtypeOrErr returns the Bloodtype value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PatientEdges) BloodtypeOrErr() (*Bloodtype, error) {
	if e.loadedTypes[2] {
		if e.Bloodtype == nil {
			// The edge bloodtype was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: bloodtype.Label}
		}
		return e.Bloodtype, nil
	}
	return nil, &NotLoadedError{edge: "bloodtype"}
}

// FrompatientOrErr returns the Frompatient value or an error if the edge
// was not loaded in eager-loading, or loaded but was not found.
func (e PatientEdges) FrompatientOrErr() (*Rent, error) {
	if e.loadedTypes[3] {
		if e.Frompatient == nil {
			// The edge frompatient was loaded in eager-loading,
			// but was not found.
			return nil, &NotFoundError{label: rent.Label}
		}
		return e.Frompatient, nil
	}
	return nil, &NotLoadedError{edge: "frompatient"}
}

// PatientCoveredPersonOrErr returns the PatientCoveredPerson value or an error if the edge
// was not loaded in eager-loading.
func (e PatientEdges) PatientCoveredPersonOrErr() ([]*CoveredPerson, error) {
	if e.loadedTypes[4] {
		return e.PatientCoveredPerson, nil
	}
	return nil, &NotLoadedError{edge: "Patient_CoveredPerson"}
}

// PatientDiagnoseOrErr returns the PatientDiagnose value or an error if the edge
// was not loaded in eager-loading.
func (e PatientEdges) PatientDiagnoseOrErr() ([]*Diagnose, error) {
	if e.loadedTypes[5] {
		return e.PatientDiagnose, nil
	}
	return nil, &NotLoadedError{edge: "patient_diagnose"}
}

// PatientPrescriptionOrErr returns the PatientPrescription value or an error if the edge
// was not loaded in eager-loading.
func (e PatientEdges) PatientPrescriptionOrErr() ([]*Prescription, error) {
	if e.loadedTypes[6] {
		return e.PatientPrescription, nil
	}
	return nil, &NotLoadedError{edge: "patient_prescription"}
}

// scanValues returns the types for scanning values from sql.Rows.
func (*Patient) scanValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{},   // id
		&sql.NullString{},  // Patient_name
		&sql.NullInt64{},   // Patient_age
		&sql.NullFloat64{}, // Patient_weight
		&sql.NullFloat64{}, // Patient_height
	}
}

// fkValues returns the types for scanning foreign-keys values from sql.Rows.
func (*Patient) fkValues() []interface{} {
	return []interface{}{
		&sql.NullInt64{}, // bloodtype_id
		&sql.NullInt64{}, // gender_id
		&sql.NullInt64{}, // prefix_id
	}
}

// assignValues assigns the values that were returned from sql.Rows (after scanning)
// to the Patient fields.
func (pa *Patient) assignValues(values ...interface{}) error {
	if m, n := len(values), len(patient.Columns); m < n {
		return fmt.Errorf("mismatch number of scan values: %d != %d", m, n)
	}
	value, ok := values[0].(*sql.NullInt64)
	if !ok {
		return fmt.Errorf("unexpected type %T for field id", value)
	}
	pa.ID = int(value.Int64)
	values = values[1:]
	if value, ok := values[0].(*sql.NullString); !ok {
		return fmt.Errorf("unexpected type %T for field Patient_name", values[0])
	} else if value.Valid {
		pa.PatientName = value.String
	}
	if value, ok := values[1].(*sql.NullInt64); !ok {
		return fmt.Errorf("unexpected type %T for field Patient_age", values[1])
	} else if value.Valid {
		pa.PatientAge = int(value.Int64)
	}
	if value, ok := values[2].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field Patient_weight", values[2])
	} else if value.Valid {
		pa.PatientWeight = value.Float64
	}
	if value, ok := values[3].(*sql.NullFloat64); !ok {
		return fmt.Errorf("unexpected type %T for field Patient_height", values[3])
	} else if value.Valid {
		pa.PatientHeight = value.Float64
	}
	values = values[4:]
	if len(values) == len(patient.ForeignKeys) {
		if value, ok := values[0].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field bloodtype_id", value)
		} else if value.Valid {
			pa.bloodtype_id = new(int)
			*pa.bloodtype_id = int(value.Int64)
		}
		if value, ok := values[1].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field gender_id", value)
		} else if value.Valid {
			pa.gender_id = new(int)
			*pa.gender_id = int(value.Int64)
		}
		if value, ok := values[2].(*sql.NullInt64); !ok {
			return fmt.Errorf("unexpected type %T for edge-field prefix_id", value)
		} else if value.Valid {
			pa.prefix_id = new(int)
			*pa.prefix_id = int(value.Int64)
		}
	}
	return nil
}

// QueryGender queries the gender edge of the Patient.
func (pa *Patient) QueryGender() *GenderQuery {
	return (&PatientClient{config: pa.config}).QueryGender(pa)
}

// QueryPrefix queries the prefix edge of the Patient.
func (pa *Patient) QueryPrefix() *PrefixQuery {
	return (&PatientClient{config: pa.config}).QueryPrefix(pa)
}

// QueryBloodtype queries the bloodtype edge of the Patient.
func (pa *Patient) QueryBloodtype() *BloodtypeQuery {
	return (&PatientClient{config: pa.config}).QueryBloodtype(pa)
}

// QueryFrompatient queries the frompatient edge of the Patient.
func (pa *Patient) QueryFrompatient() *RentQuery {
	return (&PatientClient{config: pa.config}).QueryFrompatient(pa)
}

// QueryPatientCoveredPerson queries the Patient_CoveredPerson edge of the Patient.
func (pa *Patient) QueryPatientCoveredPerson() *CoveredPersonQuery {
	return (&PatientClient{config: pa.config}).QueryPatientCoveredPerson(pa)
}

// QueryPatientDiagnose queries the patient_diagnose edge of the Patient.
func (pa *Patient) QueryPatientDiagnose() *DiagnoseQuery {
	return (&PatientClient{config: pa.config}).QueryPatientDiagnose(pa)
}

// QueryPatientPrescription queries the patient_prescription edge of the Patient.
func (pa *Patient) QueryPatientPrescription() *PrescriptionQuery {
	return (&PatientClient{config: pa.config}).QueryPatientPrescription(pa)
}

// Update returns a builder for updating this Patient.
// Note that, you need to call Patient.Unwrap() before calling this method, if this Patient
// was returned from a transaction, and the transaction was committed or rolled back.
func (pa *Patient) Update() *PatientUpdateOne {
	return (&PatientClient{config: pa.config}).UpdateOne(pa)
}

// Unwrap unwraps the entity that was returned from a transaction after it was closed,
// so that all next queries will be executed through the driver which created the transaction.
func (pa *Patient) Unwrap() *Patient {
	tx, ok := pa.config.driver.(*txDriver)
	if !ok {
		panic("ent: Patient is not a transactional entity")
	}
	pa.config.driver = tx.drv
	return pa
}

// String implements the fmt.Stringer.
func (pa *Patient) String() string {
	var builder strings.Builder
	builder.WriteString("Patient(")
	builder.WriteString(fmt.Sprintf("id=%v", pa.ID))
	builder.WriteString(", Patient_name=")
	builder.WriteString(pa.PatientName)
	builder.WriteString(", Patient_age=")
	builder.WriteString(fmt.Sprintf("%v", pa.PatientAge))
	builder.WriteString(", Patient_weight=")
	builder.WriteString(fmt.Sprintf("%v", pa.PatientWeight))
	builder.WriteString(", Patient_height=")
	builder.WriteString(fmt.Sprintf("%v", pa.PatientHeight))
	builder.WriteByte(')')
	return builder.String()
}

// Patients is a parsable slice of Patient.
type Patients []*Patient

func (pa Patients) config(cfg config) {
	for _i := range pa {
		pa[_i].config = cfg
	}
}
